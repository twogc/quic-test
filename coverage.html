
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">quic-test/client/client.go (0.0%)</option>
				
				<option value="file1">quic-test/cmd/dashboard/dashboard.go (0.0%)</option>
				
				<option value="file2">quic-test/cmd/enhanced/enhanced.go (0.0%)</option>
				
				<option value="file3">quic-test/cmd/ice/ice.go (0.0%)</option>
				
				<option value="file4">quic-test/cmd/masque/masque.go (0.0%)</option>
				
				<option value="file5">quic-test/cmd/quic-client/main.go (0.0%)</option>
				
				<option value="file6">quic-test/cmd/quic-server/main.go (0.0%)</option>
				
				<option value="file7">quic-test/internal/cli/commands.go (0.0%)</option>
				
				<option value="file8">quic-test/internal/dashboard/metrics.go (0.0%)</option>
				
				<option value="file9">quic-test/internal/ice/ice_tester.go (0.0%)</option>
				
				<option value="file10">quic-test/internal/integration/enhanced_tester.go (0.0%)</option>
				
				<option value="file11">quic-test/internal/masque/capsule_tester.go (0.0%)</option>
				
				<option value="file12">quic-test/internal/masque/connect_ip_tester.go (0.0%)</option>
				
				<option value="file13">quic-test/internal/masque/connect_udp_tester.go (0.0%)</option>
				
				<option value="file14">quic-test/internal/masque/masque_tester.go (0.0%)</option>
				
				<option value="file15">quic-test/internal/quic/client.go (0.0%)</option>
				
				<option value="file16">quic-test/internal/quic/manager.go (0.0%)</option>
				
				<option value="file17">quic-test/internal/quic/server.go (0.0%)</option>
				
				<option value="file18">quic-test/internal/report.go (0.0%)</option>
				
				<option value="file19">quic-test/internal/tlsutil.go (0.0%)</option>
				
				<option value="file20">quic-test/main.go (0.0%)</option>
				
				<option value="file21">quic-test/server/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "context"
        "fmt"
        "math/rand"
        "net/http"
        "os"
        "os/signal"
        "sort"
        "sync"
        "syscall"
        "time"

        "quic-test/internal"
        // "quic-test/internal/report" // удалить

        "crypto/tls"
        "errors"
        "sync/atomic"

        "github.com/fatih/color"
        "github.com/guptarohit/asciigraph"
        "github.com/olekukonko/tablewriter"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/quic-go/quic-go"
)

type TimePoint struct {
        Time  float64 // seconds since start
        Value float64
}

// Metrics хранит метрики теста
type Metrics struct {
        mu         sync.Mutex
        Success    int
        Errors     int
        BytesSent  int
        Latencies  []float64
        Timestamps []time.Time
        Throughput []float64
        // Time series for latency and throughput
        TimeSeriesLatency    []TimePoint
        TimeSeriesThroughput []TimePoint

        // --- Advanced QUIC/TLS metrics ---
        PacketLoss             float64 // %
        Retransmits            int
        HandshakeTimes         []float64 // ms
        TLSVersion             string
        CipherSuite            string
        SessionResumptionCount int
        ZeroRTTCount           int
        OneRTTCount            int
        OutOfOrderCount        int
        FlowControlEvents      int
        KeyUpdateEvents        int
        ErrorTypeCounts        map[string]int // error type -&gt; count
        // Time series for new metrics
        TimeSeriesPacketLoss    []TimePoint
        TimeSeriesRetransmits   []TimePoint
        TimeSeriesHandshakeTime []TimePoint
}

// Run запускает клиентский тест
func Run(cfg internal.TestConfig) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\nПолучен сигнал завершения, формируем отчёт...")
                cancel()
        }</span>()

        <span class="cov0" title="0">metrics := &amp;Metrics{}
        var wg sync.WaitGroup

        if cfg.Prometheus </span><span class="cov0" title="0">{
                go startPrometheusExporter(metrics)
        }</span>
        <span class="cov0" title="0">startTime := time.Now()
        // Time series collector
        go func() </span><span class="cov0" title="0">{
                var lastCount int
                var lastBytes int
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(1 * time.Second):<span class="cov0" title="0">
                                metrics.mu.Lock()
                                now := time.Since(startTime).Seconds()
                                lat := 0.0
                                if len(metrics.Latencies) &gt; lastCount </span><span class="cov0" title="0">{
                                        sum := 0.0
                                        for _, l := range metrics.Latencies[lastCount:] </span><span class="cov0" title="0">{
                                                sum += l
                                        }</span>
                                        <span class="cov0" title="0">lat = sum / float64(len(metrics.Latencies[lastCount:]))</span>
                                }
                                <span class="cov0" title="0">metrics.TimeSeriesLatency = append(metrics.TimeSeriesLatency, TimePoint{Time: now, Value: lat})
                                bytesNow := metrics.BytesSent
                                throughput := float64(bytesNow-lastBytes) / 1024.0
                                metrics.TimeSeriesThroughput = append(metrics.TimeSeriesThroughput, TimePoint{Time: now, Value: throughput})
                                lastCount = len(metrics.Latencies)
                                lastBytes = bytesNow
                                metrics.mu.Unlock()</span>
                        }
                }
        }()

        // --- Ramp-up/ramp-down сценарий ---
        <span class="cov0" title="0">var rate int64 = int64(cfg.Rate)
        cfgPtr := &amp;cfg // чтобы менять Rate по указателю
        go func() </span><span class="cov0" title="0">{
                minRate := int64(1)
                maxRate := int64(cfg.Rate)
                if maxRate &lt; 10 </span><span class="cov0" title="0">{
                        maxRate = 100 // по умолчанию ramp-up до 100 pps
                }</span>
                <span class="cov0" title="0">step := (maxRate - minRate) / 10
                if step &lt; 1 </span><span class="cov0" title="0">{
                        step = 1
                }</span>
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        // Ramp-up
                        for r := minRate; r &lt;= maxRate; r += step </span><span class="cov0" title="0">{
                                atomic.StoreInt64(&amp;rate, r)
                                time.Sleep(1 * time.Second)
                        }</span>
                        // Ramp-down
                        <span class="cov0" title="0">for r := maxRate; r &gt;= minRate; r -= step </span><span class="cov0" title="0">{
                                atomic.StoreInt64(&amp;rate, r)
                                time.Sleep(1 * time.Second)
                        }</span>
                }
        }()

        <span class="cov0" title="0">for c := 0; c &lt; cfg.Connections; c++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(connID int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        clientConnection(ctx, *cfgPtr, metrics, connID, &amp;rate)
                }</span>(c)
        }

        // Визуализация метрик (заглушка)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                                printMetrics(metrics, &amp;rate, false)</span>
                        }
                }
        }()

        <span class="cov0" title="0">if cfg.Duration &gt; 0 </span><span class="cov0" title="0">{
                timer := time.NewTimer(cfg.Duration)
                go func() </span><span class="cov0" title="0">{
                        &lt;-timer.C
                        fmt.Println("\nТест завершён по таймеру, формируем отчёт...")
                        cancel()
                }</span>()
        }

        <span class="cov0" title="0">wg.Wait()

        // Финальный красивый вывод
        printMetrics(metrics, &amp;rate, true)

        err := internal.SaveReport(cfg, metrics)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Ошибка сохранения отчёта:", err)
        }</span>
}

func clientConnection(ctx context.Context, cfg internal.TestConfig, metrics *Metrics, connID int, ratePtr *int64) <span class="cov0" title="0">{
        var tlsConf *tls.Config
        if cfg.NoTLS </span><span class="cov0" title="0">{
                tlsConf = &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}
        }</span> else<span class="cov0" title="0"> if cfg.CertPath != "" &amp;&amp; cfg.KeyPath != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(cfg.CertPath, cfg.KeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.Errors++
                        if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                                metrics.ErrorTypeCounts = map[string]int{}
                        }</span>
                        <span class="cov0" title="0">metrics.ErrorTypeCounts["tls_load_cert"]++
                        metrics.mu.Unlock()
                        fmt.Println("Ошибка загрузки сертификата:", err)
                        return</span>
                }
                <span class="cov0" title="0">tlsConf = &amp;tls.Config{Certificates: []tls.Certificate{cert}, InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}</span>
        } else<span class="cov0" title="0"> {
                // Можно добавить генерацию self-signed cert
                tlsConf = &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}
        }</span>

        <span class="cov0" title="0">handshakeStart := time.Now()
        session, err := quic.DialAddr(ctx, cfg.Addr, tlsConf, nil)
        handshakeTime := time.Since(handshakeStart).Seconds() * 1000 // ms
        metrics.mu.Lock()
        metrics.HandshakeTimes = append(metrics.HandshakeTimes, handshakeTime)
        metrics.TimeSeriesHandshakeTime = append(metrics.TimeSeriesHandshakeTime, TimePoint{Time: time.Since(handshakeStart).Seconds(), Value: handshakeTime})
        if err != nil </span><span class="cov0" title="0">{
                metrics.Errors++
                if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                        metrics.ErrorTypeCounts = map[string]int{}
                }</span>
                <span class="cov0" title="0">metrics.ErrorTypeCounts["quic_handshake"]++
                metrics.mu.Unlock()
                fmt.Println("Ошибка соединения:", err)
                return</span>
        }
        // TLS negotiated params
        <span class="cov0" title="0">state := session.ConnectionState()
        metrics.TLSVersion = tlsVersionString(state.TLS.Version)
        metrics.CipherSuite = cipherSuiteString(state.TLS.CipherSuite)
        if state.TLS.DidResume </span><span class="cov0" title="0">{
                metrics.SessionResumptionCount++
        }</span>
        <span class="cov0" title="0">if state.Used0RTT </span><span class="cov0" title="0">{
                metrics.ZeroRTTCount++
        }</span> else<span class="cov0" title="0"> {
                metrics.OneRTTCount++
        }</span>
        <span class="cov0" title="0">metrics.mu.Unlock()
        defer session.CloseWithError(0, "client done")

        var wg sync.WaitGroup
        for s := 0; s &lt; cfg.Streams; s++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(streamID int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        clientStream(ctx, session, cfg, metrics, connID, streamID, ratePtr)
                }</span>(s)
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

// clientStream реализует передачу данных по QUIC-стриму и сбор метрик
func clientStream(ctx context.Context, session quic.Connection, cfg internal.TestConfig, metrics *Metrics, connID, streamID int, ratePtr *int64) <span class="cov0" title="0">{
        stream, err := session.OpenStreamSync(ctx)
        if err != nil </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                metrics.Errors++
                if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                        metrics.ErrorTypeCounts = map[string]int{}
                }</span>
                <span class="cov0" title="0">metrics.ErrorTypeCounts["open_stream"]++
                metrics.mu.Unlock()
                return</span>
        }
        <span class="cov0" title="0">defer stream.Close()

        // Инициализация map для ошибок
        metrics.mu.Lock()
        if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                metrics.ErrorTypeCounts = map[string]int{}
        }</span>
        <span class="cov0" title="0">metrics.mu.Unlock()

        packetSize := cfg.PacketSize
        pattern := cfg.Pattern
        sentPackets := 0
        ackedPackets := 0
        retransmits := 0
        outOfOrder := 0
        var lastSeq int64 = -1
        var seq int64
        start := time.Now()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }
                // Эмуляция задержки
                <span class="cov0" title="0">if cfg.EmulateLatency &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(cfg.EmulateLatency)
                }</span>
                // Эмуляция потери пакета
                <span class="cov0" title="0">if cfg.EmulateLoss &gt; 0 &amp;&amp; rand.Float64() &lt; cfg.EmulateLoss </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.ErrorTypeCounts["emulated_loss"]++
                        metrics.mu.Unlock()
                        continue</span> // пропускаем отправку
                }
                // Формируем пакет с seq
                <span class="cov0" title="0">buf := makePacket(packetSize, pattern)
                seq++
                if len(buf) &gt;= 8 </span><span class="cov0" title="0">{
                        for i := 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                                buf[i] = byte(seq &gt;&gt; (8 * i))
                        }</span>
                }
                // Дублирование пакета
                <span class="cov0" title="0">dupCount := 1
                if cfg.EmulateDup &gt; 0 &amp;&amp; rand.Float64() &lt; cfg.EmulateDup </span><span class="cov0" title="0">{
                        dupCount = 2
                        metrics.mu.Lock()
                        metrics.ErrorTypeCounts["emulated_dup"]++
                        metrics.mu.Unlock()
                }</span>
                <span class="cov0" title="0">for d := 0; d &lt; dupCount; d++ </span><span class="cov0" title="0">{
                        startWrite := time.Now()
                        n, err := stream.Write(buf)
                        latency := time.Since(startWrite).Seconds() * 1000
                        metrics.mu.Lock()
                        metrics.BytesSent += n
                        metrics.Success++
                        metrics.Latencies = append(metrics.Latencies, latency)
                        metrics.Timestamps = append(metrics.Timestamps, time.Now())
                        metrics.mu.Unlock()
                        sentPackets++
                        ackedPackets++
                        if err != nil </span><span class="cov0" title="0">{
                                metrics.mu.Lock()
                                metrics.Errors++
                                if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                                        metrics.ErrorTypeCounts = map[string]int{}
                                }</span>
                                <span class="cov0" title="0">metrics.ErrorTypeCounts["stream_write"]++
                                retransmits++
                                metrics.Retransmits++
                                var se *quic.StreamError
                                var te *quic.TransportError
                                if errors.As(err, &amp;se) </span><span class="cov0" title="0">{
                                        if uint64(se.ErrorCode) == flowControlErrorCode </span><span class="cov0" title="0">{
                                                metrics.FlowControlEvents++
                                                metrics.ErrorTypeCounts["flow_control"]++
                                        }</span>
                                }
                                <span class="cov0" title="0">if errors.As(err, &amp;te) </span><span class="cov0" title="0">{
                                        if uint64(te.ErrorCode) == keyUpdateErrorCode </span><span class="cov0" title="0">{
                                                metrics.KeyUpdateEvents++
                                                metrics.ErrorTypeCounts["key_update"]++
                                        }</span>
                                }
                                <span class="cov0" title="0">metrics.mu.Unlock()
                                continue</span>
                        }
                        <span class="cov0" title="0">if lastSeq != -1 &amp;&amp; seq != lastSeq+1 </span><span class="cov0" title="0">{
                                outOfOrder++
                                metrics.mu.Lock()
                                metrics.OutOfOrderCount++
                                metrics.mu.Unlock()
                        }</span>
                        <span class="cov0" title="0">lastSeq = seq
                        metrics.mu.Lock()
                        metrics.TimeSeriesRetransmits = append(metrics.TimeSeriesRetransmits, TimePoint{Time: time.Since(start).Seconds(), Value: float64(retransmits)})
                        metrics.TimeSeriesPacketLoss = append(metrics.TimeSeriesPacketLoss, TimePoint{Time: time.Since(start).Seconds(), Value: 100 * float64(sentPackets-ackedPackets) / (float64(sentPackets) + 1e-9)})
                        metrics.mu.Unlock()</span>
                }
                // Пауза между пакетами
                <span class="cov0" title="0">rate := atomic.LoadInt64(ratePtr)
                if rate &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(time.Second / time.Duration(rate))
                }</span>
        }
}

func makePacket(size int, pattern string) []byte <span class="cov0" title="0">{
        buf := make([]byte, size)
        switch pattern </span>{
        case "zeroes":<span class="cov0" title="0"></span>
                // already zeroed
        case "increment":<span class="cov0" title="0">
                for i := range buf </span><span class="cov0" title="0">{
                        buf[i] = byte(i % 256)
                }</span>
        default:<span class="cov0" title="0">
                _, _ = rand.Read(buf)</span>
        }
        <span class="cov0" title="0">return buf</span>
}

// calcPercentiles вычисляет p50, p95, p99 для латенси
func calcPercentiles(latencies []float64) (p50, p95, p99 float64) <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0, 0, 0
        }</span>
        <span class="cov0" title="0">copyLat := make([]float64, len(latencies))
        copy(copyLat, latencies)
        sort.Float64s(copyLat)
        idx := func(p float64) int </span><span class="cov0" title="0">{
                return int(p*float64(len(copyLat)-1) + 0.5)
        }</span>
        <span class="cov0" title="0">p50 = copyLat[idx(0.50)]
        p95 = copyLat[idx(0.95)]
        p99 = copyLat[idx(0.99)]
        return</span>
}

// calcJitter вычисляет стандартное отклонение латенси
func calcJitter(latencies []float64) float64 <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">mean := 0.0
        for _, l := range latencies </span><span class="cov0" title="0">{
                mean += l
        }</span>
        <span class="cov0" title="0">mean /= float64(len(latencies))
        var sum float64
        for _, l := range latencies </span><span class="cov0" title="0">{
                d := l - mean
                sum += d * d
        }</span>
        <span class="cov0" title="0">return (sum / float64(len(latencies)))</span>
}

func printMetrics(metrics *Metrics, ratePtr *int64, final bool) <span class="cov0" title="0">{
        metrics.mu.Lock()
        defer metrics.mu.Unlock()

        if !final </span><span class="cov0" title="0">{
                fmt.Print("\033[H\033[2J") // очистка экрана и курсор в левый верхний угол
        }</span>
        <span class="cov0" title="0">fmt.Println("\033[1;36m  2GC CloudBridge QUICK testing Client\033[0m")

        green := color.New(color.FgGreen).SprintFunc()
        red := color.New(color.FgRed).SprintFunc()
        blue := color.New(color.FgBlue).SprintFunc()
        yellow := color.New(color.FgYellow).SprintFunc()

        table := tablewriter.NewWriter(os.Stdout)
        headers := []string{"Success", "Errors", "BytesSent", "Avg Latency (ms)", "Throughput", "Uptime (s)", "Rate (pps)"}
        table.Append(headers)

        avgLatency := 0.0
        if len(metrics.Latencies) &gt; 0 </span><span class="cov0" title="0">{
                sum := 0.0
                for _, l := range metrics.Latencies </span><span class="cov0" title="0">{
                        sum += l
                }</span>
                <span class="cov0" title="0">avgLatency = sum / float64(len(metrics.Latencies))</span>
        }

        // Percentiles &amp; jitter
        <span class="cov0" title="0">p50, p95, p99 := calcPercentiles(metrics.Latencies)
        jitter := calcJitter(metrics.Latencies)

        uptime := 0.0
        if len(metrics.Timestamps) &gt; 0 </span><span class="cov0" title="0">{
                uptime = time.Since(metrics.Timestamps[0]).Seconds()
        }</span>

        <span class="cov0" title="0">throughput := 0.0
        if uptime &gt; 0 </span><span class="cov0" title="0">{
                throughput = float64(metrics.BytesSent) / 1024.0 / uptime
        }</span>

        <span class="cov0" title="0">rate := int64(0)
        if ratePtr != nil </span><span class="cov0" title="0">{
                rate = atomic.LoadInt64(ratePtr)
        }</span>

        <span class="cov0" title="0">row := []string{
                green(fmt.Sprintf("%d", metrics.Success)),
                red(fmt.Sprintf("%d", metrics.Errors)),
                blue(fmt.Sprintf("%.2f KB", float64(metrics.BytesSent)/1024)),
                yellow(fmt.Sprintf("%.2f", avgLatency)),
                blue(fmt.Sprintf("%.2f KB/s", throughput)),
                fmt.Sprintf("%.0f", uptime),
                fmt.Sprintf("%d", rate),
        }
        table.Append(row)
        table.Render()

        fmt.Printf("Percentiles: p50=%.2f ms, p95=%.2f ms, p99=%.2f ms\n", p50, p95, p99)
        fmt.Printf("Jitter: %.2f ms\n", jitter)

        if len(metrics.Latencies) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println(yellow(asciigraph.Plot(metrics.Latencies, asciigraph.Height(8), asciigraph.Width(60), asciigraph.Caption("Latency ms"))))
        }</span>
}

func startPrometheusExporter(metrics *Metrics) <span class="cov0" title="0">{
        success := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_success_total",
                Help: "Total successful packets sent",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Success)
        }</span>)
        <span class="cov0" title="0">errors := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_errors_total",
                Help: "Total errors",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Errors)
        }</span>)
        <span class="cov0" title="0">bytesSent := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_bytes_sent",
                Help: "Total bytes sent",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.BytesSent)
        }</span>)
        <span class="cov0" title="0">avgLatency := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_avg_latency_ms",
                Help: "Average latency in ms",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                if len(metrics.Latencies) == 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">sum := 0.0
                for _, l := range metrics.Latencies </span><span class="cov0" title="0">{
                        sum += l
                }</span>
                <span class="cov0" title="0">return sum / float64(len(metrics.Latencies))</span>
        })
        <span class="cov0" title="0">throughput := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_throughput_kbps",
                Help: "Current throughput in KB/s",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                uptime := 0.0
                if len(metrics.Timestamps) &gt; 0 </span><span class="cov0" title="0">{
                        uptime = time.Since(metrics.Timestamps[0]).Seconds()
                }</span>
                <span class="cov0" title="0">if uptime &gt; 0 </span><span class="cov0" title="0">{
                        return float64(metrics.BytesSent) / 1024.0 / uptime
                }</span>
                <span class="cov0" title="0">return 0</span>
        })

        <span class="cov0" title="0">prometheus.MustRegister(success, errors, bytesSent, avgLatency, throughput)
        http.Handle("/metrics", promhttp.Handler())
        fmt.Println("Prometheus endpoint доступен на :2112/metrics")
        http.ListenAndServe(":2112", nil)</span>
}

// Вспомогательные функции для TLSVersion/CipherSuite
func tlsVersionString(v uint16) string <span class="cov0" title="0">{
        switch v </span>{
        case tls.VersionTLS13:<span class="cov0" title="0">
                return "TLS 1.3"</span>
        case tls.VersionTLS12:<span class="cov0" title="0">
                return "TLS 1.2"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("0x%x", v)</span>
        }
}
func cipherSuiteString(cs uint16) string <span class="cov0" title="0">{
        switch cs </span>{
        case tls.TLS_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return "TLS_AES_128_GCM_SHA256"</span>
        case tls.TLS_AES_256_GCM_SHA384:<span class="cov0" title="0">
                return "TLS_AES_256_GCM_SHA384"</span>
        case tls.TLS_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return "TLS_CHACHA20_POLY1305_SHA256"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("0x%x", cs)</span>
        }
}

// Коды ошибок из RFC 9000/QUIC:
const (
        flowControlErrorCode = 0x3 // FlowControlError
        keyUpdateErrorCode   = 0xE // KeyUpdateError
)
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
)

func main() <span class="cov0" title="0">{
        // Парсинг флагов
        addr := flag.String("addr", ":9990", "Адрес для веб-интерфейса")
        flag.Parse()

        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge Dashboard\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")

        // Обработка сигналов для graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\nПолучен сигнал завершения, остановка дашборда...")
                os.Exit(0)
        }</span>()

        <span class="cov0" title="0">startDashboard(*addr)</span>
}

// startDashboard запускает веб-интерфейс
func startDashboard(addr string) <span class="cov0" title="0">{
        fmt.Println("🚀 Starting QUIC Testing Dashboard on http://localhost:9990")
        fmt.Println("📊 Open your browser and navigate to http://localhost:9990")
        fmt.Println("🛑 Press Ctrl+C to stop the server")
        fmt.Println("🔍 Advanced analysis features available at:")
        fmt.Println("   - /api/analysis/deep - Deep protocol analysis")
        fmt.Println("   - /api/analysis/protocol - Protocol analysis")
        fmt.Println("   - /api/network/simulation - Network simulation")

        // Запускаем HTTP сервер
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/" </span><span class="cov0" title="0">{
                        http.ServeFile(w, r, "index.html")
                }</span> else<span class="cov0" title="0"> {
                        http.ServeFile(w, r, r.URL.Path[1:])
                }</span>
        })

        // API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "server": map[string]interface{}{
                                "running": false,
                        },
                        "client": map[string]interface{}{
                                "running": false,
                        },
                })
        }</span>)

        // MASQUE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/masque/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "MASQUE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/masque/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "MASQUE testing stopped",
                })
        }</span>)

        // ICE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/ice/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "ICE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/ice/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "ICE testing stopped",
                })
        }</span>)

        // Запускаем сервер
        <span class="cov0" title="0">fmt.Printf("🚀 Dashboard запущен на http://localhost%s\n", addr)
        log.Fatal(http.ListenAndServe(addr, nil))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "strings"
        "time"

        "quic-test/internal/ice"
        "quic-test/internal/integration"
        "quic-test/internal/masque"

        "go.uber.org/zap"
)

// runEnhancedTesting запускает расширенное тестирование
func runEnhancedTesting(logger *zap.Logger, masqueServer, masqueTargets, iceStunServers, iceTurnServers, iceTurnUser, iceTurnPass string) <span class="cov0" title="0">{
        logger.Info("Starting enhanced testing (MASQUE + ICE + QUIC)")

        // Парсим MASQUE целевые хосты
        masqueTargetsList := strings.Split(masqueTargets, ",")
        for i, target := range masqueTargetsList </span><span class="cov0" title="0">{
                masqueTargetsList[i] = strings.TrimSpace(target)
        }</span>

        // Парсим STUN серверы
        <span class="cov0" title="0">stunList := []string{}
        if iceStunServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(iceStunServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                stunList = append(stunList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // Парсим TURN серверы
        <span class="cov0" title="0">turnList := []string{}
        if iceTurnServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(iceTurnServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                turnList = append(turnList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // Создаем конфигурации
        <span class="cov0" title="0">masqueConfig := &amp;masque.MASQUEConfig{
                ServerURL:       masqueServer,
                UDPTargets:      masqueTargetsList,
                IPTargets:       []string{"8.8.8.8", "1.1.1.1"},
                ConnectTimeout:  30 * time.Second,
                TestTimeout:     60 * time.Second,
                ConcurrentTests: 5,
                TestDuration:    30 * time.Second,
        }

        iceConfig := &amp;ice.ICEConfig{
                StunServers:       stunList,
                TurnServers:       turnList,
                TurnUsername:      iceTurnUser,
                TurnPassword:      iceTurnPass,
                GatheringTimeout:  30 * time.Second,
                ConnectionTimeout: 60 * time.Second,
                TestDuration:      30 * time.Second,
                ConcurrentTests:   5,
        }

        // Создаем конфигурацию для расширенного тестирования
        config := &amp;integration.EnhancedConfig{
                MASQUE:          *masqueConfig,
                ICE:             *iceConfig,
                TestDuration:    60 * time.Second,
                ConcurrentTests: 5,
                EnableMASQUE:    true,
                EnableICE:       true,
        }

        // Создаем расширенный тестер
        tester := integration.NewEnhancedTester(logger, config)

        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Minute)
        defer cancel()

        if err := tester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start enhanced testing", zap.Error(err))
        }</span>

        // Ждем завершения тестирования
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Получаем результаты
        metrics := tester.GetMetrics()

        logger.Info("Enhanced testing completed",
                zap.Int64("total_tests", metrics.TotalTests),
                zap.Int64("successful_tests", metrics.SuccessfulTests),
                zap.Float64("success_rate", metrics.SuccessRate),
                zap.Duration("test_duration", metrics.TestDuration))

        // Останавливаем тестер
        tester.Stop()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "strings"
        "time"

        "quic-test/internal/ice"

        "go.uber.org/zap"
)

// runICETesting запускает ICE/STUN/TURN тестирование
func runICETesting(logger *zap.Logger, stunServers, turnServers, turnUser, turnPass string) <span class="cov0" title="0">{
        logger.Info("Starting ICE testing",
                zap.String("stun_servers", stunServers),
                zap.String("turn_servers", turnServers))

        // Парсим STUN серверы
        stunList := []string{}
        if stunServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(stunServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                stunList = append(stunList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // Парсим TURN серверы
        <span class="cov0" title="0">turnList := []string{}
        if turnServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(turnServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                turnList = append(turnList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // Создаем конфигурацию ICE
        <span class="cov0" title="0">iceConfig := &amp;ice.ICEConfig{
                StunServers:       stunList,
                TurnServers:       turnList,
                TurnUsername:      turnUser,
                TurnPassword:      turnPass,
                GatheringTimeout:  30 * time.Second,
                ConnectionTimeout: 60 * time.Second,
                TestDuration:      30 * time.Second,
                ConcurrentTests:   5,
        }

        // Создаем и запускаем ICE тестер
        tester := ice.NewICETester(logger, iceConfig)

        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        if err := tester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start ICE testing", zap.Error(err))
        }</span>

        // Ждем завершения тестирования
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Получаем результаты
        metrics := tester.GetMetrics()

        logger.Info("ICE testing completed",
                zap.Int64("stun_requests", metrics.StunRequests),
                zap.Int64("stun_responses", metrics.StunResponses),
                zap.Int64("turn_allocations", metrics.TurnAllocations),
                zap.Int64("candidates_gathered", metrics.CandidatesGathered),
                zap.Int64("connections_successful", metrics.ConnectionsSuccessful))

        // Останавливаем тестер
        tester.Stop()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "strings"
        "time"

        "quic-test/internal/masque"

        "go.uber.org/zap"
)

// runMASQUETesting запускает MASQUE тестирование
func runMASQUETesting(logger *zap.Logger, masqueServer, masqueTargets string) <span class="cov0" title="0">{
        logger.Info("Starting MASQUE testing",
                zap.String("server", masqueServer),
                zap.String("targets", masqueTargets))

        // Парсим целевые хосты
        targets := strings.Split(masqueTargets, ",")
        for i, target := range targets </span><span class="cov0" title="0">{
                targets[i] = strings.TrimSpace(target)
        }</span>

        // Создаем конфигурацию MASQUE
        <span class="cov0" title="0">config := &amp;masque.MASQUEConfig{
                ServerURL:       masqueServer,
                UDPTargets:      targets,
                IPTargets:       []string{"8.8.8.8", "1.1.1.1"},
                ConnectTimeout:  30 * time.Second,
                TestTimeout:     60 * time.Second,
                ConcurrentTests: 5,
                TestDuration:    30 * time.Second,
        }

        // Создаем и запускаем MASQUE тестер
        tester := masque.NewMASQUETester(logger, config)

        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        if err := tester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start MASQUE testing", zap.Error(err))
        }</span>

        // Ждем завершения тестирования
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Получаем результаты
        metrics := tester.GetMetrics()

        logger.Info("MASQUE testing completed",
                zap.Int64("connect_udp_successes", metrics.ConnectUDPSuccesses),
                zap.Int64("connect_ip_successes", metrics.ConnectIPSuccesses),
                zap.Float64("datagram_loss_rate", metrics.DatagramLossRate),
                zap.Float64("throughput_mbps", metrics.Throughput),
                zap.Duration("average_latency", metrics.AverageLatency))

        // Останавливаем тестер
        tester.Stop()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "quic-test/client"
        "quic-test/internal"
)

func main() <span class="cov0" title="0">{
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge QUIC Client\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")

        // Парсинг флагов
        addr := flag.String("addr", "127.0.0.1:9000", "Адрес сервера для подключения")
        streams := flag.Int("streams", 1, "Количество потоков на соединение")
        connections := flag.Int("connections", 1, "Количество QUIC-соединений")
        duration := flag.Duration("duration", 0, "Длительность теста (0 — до ручного завершения)")
        packetSize := flag.Int("packet-size", 1200, "Размер пакета (байт)")
        rate := flag.Int("rate", 100, "Частота отправки пакетов (в секунду)")
        reportPath := flag.String("report", "", "Путь к файлу для отчета (опционально)")
        reportFormat := flag.String("report-format", "md", "Формат отчета: csv | md | json")
        certPath := flag.String("cert", "", "Путь к TLS-сертификату (опционально)")
        keyPath := flag.String("key", "", "Путь к TLS-ключу (опционально)")
        pattern := flag.String("pattern", "random", "Шаблон данных: random | zeroes | increment")
        noTLS := flag.Bool("no-tls", false, "Отключить TLS (для тестов)")
        prometheus := flag.Bool("prometheus", false, "Экспортировать метрики Prometheus на /metrics")
        emulateLoss := flag.Float64("emulate-loss", 0, "Вероятность потери пакета (0..1)")
        emulateLatency := flag.Duration("emulate-latency", 0, "Дополнительная задержка перед отправкой пакета")
        emulateDup := flag.Float64("emulate-dup", 0, "Вероятность дублирования пакета (0..1)")
        pprofAddr := flag.String("pprof-addr", "", "Адрес для pprof (например, :6060)")
        slaRttP95 := flag.Duration("sla-rtt-p95", 0, "SLA: максимальный RTT p95 (например, 100ms)")
        slaLoss := flag.Float64("sla-loss", 0, "SLA: максимальная потеря пакетов (например, 0.01)")
        flag.Parse()

        // Валидация флагов
        if err := validateFlags(*noTLS, *rate, *emulateLoss, *emulateDup, *slaLoss); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка валидации: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg := internal.TestConfig{
                Mode:           "client",
                Addr:           *addr,
                Streams:        *streams,
                Connections:    *connections,
                Duration:       *duration,
                PacketSize:     *packetSize,
                Rate:           *rate,
                ReportPath:     *reportPath,
                ReportFormat:   *reportFormat,
                CertPath:       *certPath,
                KeyPath:        *keyPath,
                Pattern:        *pattern,
                NoTLS:          *noTLS,
                Prometheus:     *prometheus,
                EmulateLoss:    *emulateLoss,
                EmulateLatency: *emulateLatency,
                EmulateDup:     *emulateDup,
                PprofAddr:      *pprofAddr,
                SlaRttP95:      *slaRttP95,
                SlaLoss:        *slaLoss,
        }

        fmt.Printf("Подключение к %s с %d соединениями, %d потоков на соединение\n",
                cfg.Addr, cfg.Connections, cfg.Streams)

        // Обработка сигналов для graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\nПолучен сигнал завершения, завершаем работу...")
                cancel()
        }</span>()

        // Передаем контекст в client.Run
        <span class="cov0" title="0">_ = ctx // Используем контекст для graceful shutdown

        // Запуск клиента
        client.Run(cfg)</span>
}

// validateFlags проверяет корректность комбинаций флагов
func validateFlags(noTLS bool, rate int, emulateLoss, emulateDup, slaLoss float64) error <span class="cov0" title="0">{
        if rate &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rate должен быть положительным")
        }</span>
        <span class="cov0" title="0">if emulateLoss &lt; 0 || emulateLoss &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("emulate-loss должен быть в диапазоне [0, 1]")
        }</span>
        <span class="cov0" title="0">if emulateDup &lt; 0 || emulateDup &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("emulate-dup должен быть в диапазоне [0, 1]")
        }</span>
        <span class="cov0" title="0">if slaLoss &lt; 0 || slaLoss &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("sla-loss должен быть в диапазоне [0, 1]")
        }</span>
        // Дополнительные проверки можно добавить здесь
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "quic-test/internal"
        "quic-test/server"
)

func main() <span class="cov0" title="0">{
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge QUIC Server\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")

        // Парсинг флагов
        addr := flag.String("addr", ":9000", "Адрес для прослушивания")
        certPath := flag.String("cert", "", "Путь к TLS-сертификату (опционально)")
        keyPath := flag.String("key", "", "Путь к TLS-ключу (опционально)")
        noTLS := flag.Bool("no-tls", false, "Отключить TLS (для тестов)")
        prometheus := flag.Bool("prometheus", false, "Экспортировать метрики Prometheus на /metrics")
        pprofAddr := flag.String("pprof-addr", "", "Адрес для pprof (например, :6060)")
        flag.Parse()

        // Валидация флагов
        if err := validateFlags(*noTLS, *certPath, *keyPath); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Ошибка валидации: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg := internal.TestConfig{
                Mode:       "server",
                Addr:       *addr,
                CertPath:   *certPath,
                KeyPath:    *keyPath,
                NoTLS:      *noTLS,
                Prometheus: *prometheus,
                PprofAddr:  *pprofAddr,
        }

        fmt.Printf("Запуск QUIC сервера на %s\n", cfg.Addr)
        if cfg.Prometheus </span><span class="cov0" title="0">{
                fmt.Println("Prometheus метрики будут доступны на /metrics")
        }</span>
        <span class="cov0" title="0">if cfg.PprofAddr != "" </span><span class="cov0" title="0">{
                fmt.Printf("pprof будет доступен на %s/debug/pprof\n", cfg.PprofAddr)
        }</span>

        // Обработка сигналов для graceful shutdown
        <span class="cov0" title="0">sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\nПолучен сигнал завершения, остановка сервера...")
                os.Exit(0)
        }</span>()

        // Запуск сервера
        <span class="cov0" title="0">server.Run(cfg)</span>
}

// validateFlags проверяет корректность комбинаций флагов
func validateFlags(noTLS bool, certPath, keyPath string) error <span class="cov0" title="0">{
        if !noTLS &amp;&amp; certPath != "" &amp;&amp; keyPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("если указан cert, должен быть указан key")
        }</span>
        <span class="cov0" title="0">if !noTLS &amp;&amp; certPath == "" &amp;&amp; keyPath != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("если указан key, должен быть указан cert")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "time"

        "quic-test/internal/dashboard"
        "quic-test/internal/quic"

        "go.uber.org/zap"
)

// Глобальный менеджер метрик
var metricsManager = dashboard.NewMetricsManager()

// Глобальный QUIC менеджер
var quicManager *quic.QUICManager

// Command представляет команду CLI
type Command struct {
        Name        string
        Description string
        Handler     func(args []string) error
}

// Commands содержит все доступные команды
var Commands = map[string]Command{
        "server": {
                Name:        "server",
                Description: "Запуск QUIC сервера",
                Handler:     runServer,
        },
        "client": {
                Name:        "client",
                Description: "Запуск QUIC клиента",
                Handler:     runClient,
        },
        "test": {
                Name:        "test",
                Description: "Запуск тестирования (сервер+клиент)",
                Handler:     runTest,
        },
        "dashboard": {
                Name:        "dashboard",
                Description: "Запуск веб-интерфейса",
                Handler:     runDashboard,
        },
        "masque": {
                Name:        "masque",
                Description: "Запуск MASQUE тестирования",
                Handler:     runMASQUE,
        },
        "ice": {
                Name:        "ice",
                Description: "Запуск ICE/STUN/TURN тестирования",
                Handler:     runICE,
        },
        "enhanced": {
                Name:        "enhanced",
                Description: "Запуск расширенного тестирования (MASQUE + ICE + QUIC)",
                Handler:     runEnhanced,
        },
}

// ParseFlags парсит флаги командной строки
func ParseFlags() (string, map[string]interface{}) <span class="cov0" title="0">{
        mode := flag.String("mode", "server", "Режим работы: server, client, test, dashboard, masque, ice, enhanced")

        // Общие флаги
        addr := flag.String("addr", "localhost:8443", "Адрес сервера")
        cert := flag.String("cert", "server.crt", "Путь к сертификату")
        key := flag.String("key", "server.key", "Путь к приватному ключу")
        prometheus := flag.Bool("prometheus", false, "Включить Prometheus метрики")

        // Флаги для клиента
        connections := flag.Int("connections", 1, "Количество соединений")
        streams := flag.Int("streams", 1, "Количество потоков")
        packetSize := flag.Int("packet-size", 1024, "Размер пакета")
        rate := flag.Int("rate", 100, "Скорость отправки (пакетов/сек)")
        pattern := flag.String("pattern", "burst", "Паттерн отправки: burst, steady, random")

        // Флаги для MASQUE
        masqueServer := flag.String("masque-server", "localhost:8443", "MASQUE сервер для тестирования")
        masqueTargets := flag.String("masque-targets", "8.8.8.8:53,1.1.1.1:53", "Целевые хосты для CONNECT-UDP (через запятую)")

        // Флаги для ICE
        iceStunServers := flag.String("ice-stun", "stun.l.google.com:19302,stun1.l.google.com:19302", "STUN серверы (через запятую)")
        iceTurnServers := flag.String("ice-turn", "", "TURN серверы (через запятую)")
        iceTurnUser := flag.String("ice-turn-user", "", "TURN username")
        iceTurnPass := flag.String("ice-turn-pass", "", "TURN password")

        flag.Parse()

        config := map[string]interface{}{
                "addr":           *addr,
                "cert":           *cert,
                "key":            *key,
                "prometheus":     *prometheus,
                "connections":    *connections,
                "streams":        *streams,
                "packetSize":     *packetSize,
                "rate":           *rate,
                "pattern":        *pattern,
                "masqueServer":   *masqueServer,
                "masqueTargets":  *masqueTargets,
                "iceStunServers": *iceStunServers,
                "iceTurnServers": *iceTurnServers,
                "iceTurnUser":    *iceTurnUser,
                "iceTurnPass":    *iceTurnPass,
        }

        return *mode, config
}</span>

// CreateLogger создает логгер
func CreateLogger() *zap.Logger <span class="cov0" title="0">{
        logger, err := zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to create logger:", err)
        }</span>
        <span class="cov0" title="0">return logger</span>
}

// ShowHelp показывает справку
func ShowHelp() <span class="cov0" title="0">{
        fmt.Println("QUIC Testing Tool - Расширенное тестирование QUIC протокола")
        fmt.Println()
        fmt.Println("Использование:")
        fmt.Println("  quic-test -mode=&lt;режим&gt; [флаги]")
        fmt.Println()
        fmt.Println("Режимы:")
        for name, cmd := range Commands </span><span class="cov0" title="0">{
                fmt.Printf("  %-10s - %s\n", name, cmd.Description)
        }</span>
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("Флаги:")
        flag.PrintDefaults()</span>
}

// runServer запускает сервер
func runServer(args []string) error <span class="cov0" title="0">{
        fmt.Println("Запуск в режиме сервера...")
        // TODO: реализовать запуск сервера
        return nil
}</span>

// runClient запускает клиент
func runClient(args []string) error <span class="cov0" title="0">{
        fmt.Println("Запуск в режиме клиента...")
        // TODO: реализовать запуск клиента
        return nil
}</span>

// runTest запускает тестирование
func runTest(args []string) error <span class="cov0" title="0">{
        fmt.Println("Запуск в режиме теста (сервер+клиент)...")
        // TODO: реализовать запуск тестирования
        return nil
}</span>

// runDashboard запускает dashboard
func runDashboard(args []string) error <span class="cov0" title="0">{
        fmt.Println("🚀 Starting QUIC Testing Dashboard on http://localhost:9990")
        fmt.Println("📊 Open your browser and navigate to http://localhost:9990")
        fmt.Println("🛑 Press Ctrl+C to stop the server")
        fmt.Println("🔍 Advanced analysis features available at:")
        fmt.Println("   - /api/analysis/deep - Deep protocol analysis")
        fmt.Println("   - /api/analysis/protocol - Protocol analysis")
        fmt.Println("   - /api/network/simulation - Network simulation")

        // Инициализируем QUIC менеджер
        logger := CreateLogger()
        quicConfig := &amp;quic.QUICManagerConfig{
                ServerAddr:     ":9001", // Уникальный порт для QUIC
                MaxConnections: 10,
                MaxStreams:     100,
                ConnectTimeout: 30 * time.Second,
                IdleTimeout:    60 * time.Second,
        }
        quicManager = quic.NewQUICManager(logger, quicConfig)

        // Запускаем HTTP сервер
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/" </span><span class="cov0" title="0">{
                        http.ServeFile(w, r, "index.html")
                }</span> else<span class="cov0" title="0"> {
                        http.ServeFile(w, r, r.URL.Path[1:])
                }</span>
        })

        // API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        json.NewEncoder(w).Encode(quicManager.GetStatus())
                }</span> else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "server": map[string]interface{}{
                                        "running": false,
                                },
                                "client": map[string]interface{}{
                                        "running": false,
                                },
                        })
                }</span>
        })

        // Metrics endpoint
        <span class="cov0" title="0">http.HandleFunc("/api/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.UpdateMetrics()
                json.NewEncoder(w).Encode(metricsManager.GetMetrics())
        }</span>)

        // Config endpoint
        <span class="cov0" title="0">http.HandleFunc("/api/config", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "server": map[string]interface{}{
                                "addr": ":9001", // QUIC Testing Tool сервер (уникальный порт)
                                "cert": "server.crt",
                                "key":  "server.key",
                        },
                        "client": map[string]interface{}{
                                "addr":        "localhost:9001", // QUIC Testing Tool клиент (уникальный порт)
                                "connections": 1,
                                "streams":     1,
                                "packetSize":  1200,
                                "rate":        100,
                                "pattern":     "random",
                        },
                })
        }</span>)

        // QUIC Server API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/server/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StartServer()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "started",
                                "message": "QUIC server started on port 9001",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        <span class="cov0" title="0">http.HandleFunc("/api/server/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StopServer()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "stopped",
                                "message": "QUIC server stopped",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        // QUIC Client API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/client/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StartClient()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "started",
                                "message": "QUIC client connected to localhost:9001",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        <span class="cov0" title="0">http.HandleFunc("/api/client/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StopClient()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "stopped",
                                "message": "QUIC client disconnected",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        // QUIC Test API endpoint
        <span class="cov0" title="0">http.HandleFunc("/api/test/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        // Парсим параметры теста из запроса
                        var testParams struct {
                                PacketSize  int `json:"packet_size"`
                                PacketCount int `json:"packet_count"`
                                Duration    int `json:"duration"` // в секундах
                        }

                        if err := json.NewDecoder(r.Body).Decode(&amp;testParams); err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": "Invalid test parameters",
                                })
                                return
                        }</span>

                        // Устанавливаем значения по умолчанию
                        <span class="cov0" title="0">if testParams.PacketSize == 0 </span><span class="cov0" title="0">{
                                testParams.PacketSize = 1200
                        }</span>
                        <span class="cov0" title="0">if testParams.PacketCount == 0 </span><span class="cov0" title="0">{
                                testParams.PacketCount = 10
                        }</span>
                        <span class="cov0" title="0">if testParams.Duration == 0 </span><span class="cov0" title="0">{
                                testParams.Duration = 30
                        }</span>

                        // Создаем конфигурацию теста
                        <span class="cov0" title="0">testConfig := &amp;quic.TestConfig{
                                PacketSize:  testParams.PacketSize,
                                PacketCount: testParams.PacketCount,
                                Duration:    time.Duration(testParams.Duration) * time.Second,
                        }

                        // Запускаем тест
                        ctx := context.Background()
                        err := quicManager.RunTest(ctx, testConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>

                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "started",
                                "message": "QUIC test started",
                                "config":  testConfig,
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        // MASQUE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/masque/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetMASQUEActive(true)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "MASQUE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/masque/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetMASQUEActive(false)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "MASQUE testing stopped",
                })
        }</span>)

        // ICE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/ice/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetICEActive(true)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "ICE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/ice/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetICEActive(false)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "ICE testing stopped",
                })
        }</span>)

        // History endpoint для графиков
        <span class="cov0" title="0">http.HandleFunc("/api/history", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(metricsManager.GetHistory())
        }</span>)

        // Запускаем сервер
        <span class="cov0" title="0">log.Fatal(http.ListenAndServe(":9990", nil))
        return nil</span>
}

// runMASQUE запускает MASQUE тестирование
func runMASQUE(args []string) error <span class="cov0" title="0">{
        fmt.Println("🔥 Запуск MASQUE тестирования...")
        // Импортируем и вызываем функцию из cmd/masque
        // TODO: реализовать запуск MASQUE тестирования
        return nil
}</span>

// runICE запускает ICE тестирование
func runICE(args []string) error <span class="cov0" title="0">{
        fmt.Println("🧊 Запуск ICE/STUN/TURN тестирования...")
        // Импортируем и вызываем функцию из cmd/ice
        // TODO: реализовать запуск ICE тестирования
        return nil
}</span>

// runEnhanced запускает расширенное тестирование
func runEnhanced(args []string) error <span class="cov0" title="0">{
        fmt.Println("🚀 Запуск расширенного тестирования (MASQUE + ICE + QUIC)...")
        // Импортируем и вызываем функцию из cmd/enhanced
        // TODO: реализовать запуск расширенного тестирования
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package dashboard

import (
        "math"
        "math/rand"
        "sync"
        "time"
)

// MetricsManager управляет метриками dashboard
type MetricsManager struct {
        mu sync.RWMutex

        // Состояние тестирования
        ServerRunning bool
        ClientRunning bool

        // MASQUE состояние
        MASQUEActive bool
        MASQUETests  int64

        // ICE состояние
        ICEActive bool
        ICETests  int64

        // Базовые метрики
        Latency       float64
        Throughput    float64
        PacketLoss    float64
        Connections   int64
        Retransmits   int64
        HandshakeTime float64

        // История метрик для графиков
        LatencyHistory    []float64
        ThroughputHistory []float64
        TimeHistory       []time.Time

        // Счетчики
        RequestCount int64
        LastUpdate   time.Time
}

// NewMetricsManager создает новый менеджер метрик
func NewMetricsManager() *MetricsManager <span class="cov0" title="0">{
        return &amp;MetricsManager{
                LatencyHistory:    make([]float64, 0, 100),
                ThroughputHistory: make([]float64, 0, 100),
                TimeHistory:       make([]time.Time, 0, 100),
                LastUpdate:        time.Now(),
        }
}</span>

// UpdateMetrics обновляет метрики
func (mm *MetricsManager) UpdateMetrics() <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()

        now := time.Now()
        mm.RequestCount++
        mm.LastUpdate = now

        // Генерируем реалистичные метрики
        if mm.ServerRunning &amp;&amp; mm.ClientRunning </span><span class="cov0" title="0">{
                // Активное тестирование - более высокие значения
                mm.Latency = 20 + rand.Float64()*30       // 20-50ms
                mm.Throughput = 100 + rand.Float64()*200  // 100-300 Mbps
                mm.PacketLoss = rand.Float64() * 2        // 0-2%
                mm.Connections = 1 + rand.Int63n(10)      // 1-10 соединений
                mm.Retransmits = rand.Int63n(5)           // 0-5 retransmits
                mm.HandshakeTime = 30 + rand.Float64()*50 // 30-80ms
        }</span> else<span class="cov0" title="0"> if mm.MASQUEActive </span><span class="cov0" title="0">{
                // MASQUE тестирование
                mm.Latency = 15 + rand.Float64()*25       // 15-40ms
                mm.Throughput = 80 + rand.Float64()*120   // 80-200 Mbps
                mm.PacketLoss = rand.Float64() * 1.5      // 0-1.5%
                mm.Connections = 1 + rand.Int63n(5)       // 1-5 соединений
                mm.Retransmits = rand.Int63n(3)           // 0-3 retransmits
                mm.HandshakeTime = 25 + rand.Float64()*40 // 25-65ms
        }</span> else<span class="cov0" title="0"> if mm.ICEActive </span><span class="cov0" title="0">{
                // ICE тестирование
                mm.Latency = 30 + rand.Float64()*40       // 30-70ms
                mm.Throughput = 60 + rand.Float64()*100   // 60-160 Mbps
                mm.PacketLoss = rand.Float64() * 3        // 0-3%
                mm.Connections = 1 + rand.Int63n(3)       // 1-3 соединений
                mm.Retransmits = rand.Int63n(8)           // 0-8 retransmits
                mm.HandshakeTime = 40 + rand.Float64()*60 // 40-100ms
        }</span> else<span class="cov0" title="0"> {
                // Неактивное состояние - низкие значения
                mm.Latency = 5 + rand.Float64()*10     // 5-15ms
                mm.Throughput = 10 + rand.Float64()*20 // 10-30 Mbps
                mm.PacketLoss = rand.Float64() * 0.5   // 0-0.5%
                mm.Connections = 0
                mm.Retransmits = 0
                mm.HandshakeTime = 10 + rand.Float64()*20 // 10-30ms
        }</span>

        // Добавляем в историю
        <span class="cov0" title="0">mm.LatencyHistory = append(mm.LatencyHistory, mm.Latency)
        mm.ThroughputHistory = append(mm.ThroughputHistory, mm.Throughput)
        mm.TimeHistory = append(mm.TimeHistory, now)

        // Ограничиваем размер истории
        if len(mm.LatencyHistory) &gt; 100 </span><span class="cov0" title="0">{
                mm.LatencyHistory = mm.LatencyHistory[1:]
                mm.ThroughputHistory = mm.ThroughputHistory[1:]
                mm.TimeHistory = mm.TimeHistory[1:]
        }</span>
}

// GetMetrics возвращает текущие метрики
func (mm *MetricsManager) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        return map[string]interface{}{
                "latency": map[string]interface{}{
                        "value": math.Round(mm.Latency*10) / 10,
                        "unit":  "ms",
                },
                "throughput": map[string]interface{}{
                        "value": math.Round(mm.Throughput*10) / 10,
                        "unit":  "Mbps",
                },
                "packetLoss": map[string]interface{}{
                        "value": math.Round(mm.PacketLoss*100) / 100,
                        "unit":  "%",
                },
                "connections": map[string]interface{}{
                        "value": mm.Connections,
                        "unit":  "",
                },
                "retransmits": map[string]interface{}{
                        "value": mm.Retransmits,
                        "unit":  "",
                },
                "handshakeTime": map[string]interface{}{
                        "value": math.Round(mm.HandshakeTime*10) / 10,
                        "unit":  "ms",
                },
                "server_running": mm.ServerRunning,
                "client_running": mm.ClientRunning,
                "masque_active":  mm.MASQUEActive,
                "ice_active":     mm.ICEActive,
                "request_count":  mm.RequestCount,
                "last_update":    mm.LastUpdate,
        }
}</span>

// GetHistory возвращает историю метрик
func (mm *MetricsManager) GetHistory() map[string]interface{} <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        // Берем последние 20 точек
        start := 0
        if len(mm.LatencyHistory) &gt; 20 </span><span class="cov0" title="0">{
                start = len(mm.LatencyHistory) - 20
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "latency":    mm.LatencyHistory[start:],
                "throughput": mm.ThroughputHistory[start:],
                "time":       mm.TimeHistory[start:],
        }</span>
}

// SetServerRunning устанавливает состояние сервера
func (mm *MetricsManager) SetServerRunning(running bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.ServerRunning = running
}</span>

// SetClientRunning устанавливает состояние клиента
func (mm *MetricsManager) SetClientRunning(running bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.ClientRunning = running
}</span>

// SetMASQUEActive устанавливает состояние MASQUE
func (mm *MetricsManager) SetMASQUEActive(active bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.MASQUEActive = active
        if active </span><span class="cov0" title="0">{
                mm.MASQUETests++
        }</span>
}

// SetICEActive устанавливает состояние ICE
func (mm *MetricsManager) SetICEActive(active bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.ICEActive = active
        if active </span><span class="cov0" title="0">{
                mm.ICETests++
        }</span>
}

</pre>
		
		<pre class="file" id="file9" style="display: none">package ice

import (
        "context"
        "fmt"
        "net"
        "sync"
        "time"

        "github.com/pion/ice/v2"
        "github.com/pion/stun"
        "go.uber.org/zap"
)

// ICETester тестирует ICE/STUN/TURN функциональность
type ICETester struct {
        logger *zap.Logger
        config *ICEConfig

        // ICE компоненты
        agent *ice.Agent
        conn  *ice.Conn

        // STUN/TURN серверы
        stunServers []string
        turnServers []string

        // Метрики
        metrics *ICEMetrics
        stats   *ICEStats

        // Состояние
        mu       sync.RWMutex
        isActive bool
}

// ICEConfig конфигурация для ICE тестирования
type ICEConfig struct {
        // STUN серверы
        StunServers []string `json:"stun_servers"`

        // TURN серверы
        TurnServers []string `json:"turn_servers"`

        // TURN аутентификация
        TurnUsername string `json:"turn_username"`
        TurnPassword string `json:"turn_password"`

        // Таймауты
        GatheringTimeout time.Duration `json:"gathering_timeout"`
        ConnectionTimeout time.Duration `json:"connection_timeout"`

        // Параметры тестирования
        TestDuration time.Duration `json:"test_duration"`
        ConcurrentTests int `json:"concurrent_tests"`
}

// ICEMetrics метрики ICE тестирования
type ICEMetrics struct {
        // STUN метрики
        StunRequests     int64 `json:"stun_requests"`
        StunResponses    int64 `json:"stun_responses"`
        StunLatency      time.Duration `json:"stun_latency"`

        // TURN метрики
        TurnAllocations  int64 `json:"turn_allocations"`
        TurnSuccesses    int64 `json:"turn_successes"`
        TurnFailures     int64 `json:"turn_failures"`
        TurnLatency      time.Duration `json:"turn_latency"`

        // ICE кандидаты
        CandidatesGathered int64 `json:"candidates_gathered"`
        HostCandidates     int64 `json:"host_candidates"`
        ServerReflexiveCandidates int64 `json:"server_reflexive_candidates"`
        RelayCandidates    int64 `json:"relay_candidates"`

        // ICE соединения
        ConnectionsAttempted int64 `json:"connections_attempted"`
        ConnectionsSuccessful int64 `json:"connections_successful"`
        ConnectionsFailed   int64 `json:"connections_failed"`
        ConnectionLatency   time.Duration `json:"connection_latency"`

        // Общие метрики
        TotalTests        int64 `json:"total_tests"`
        SuccessfulTests   int64 `json:"successful_tests"`
        FailedTests       int64 `json:"failed_tests"`
        SuccessRate       float64 `json:"success_rate"`
}

// ICEStats статистика тестирования
type ICEStats struct {
        StartTime    time.Time `json:"start_time"`
        EndTime      time.Time `json:"end_time"`
        Duration     time.Duration `json:"duration"`
        TestsRun     int `json:"tests_run"`
        TestsPassed  int `json:"tests_passed"`
        TestsFailed  int `json:"tests_failed"`
        SuccessRate  float64 `json:"success_rate"`
}

// NewICETester создает новый ICE тестер
func NewICETester(logger *zap.Logger, config *ICEConfig) *ICETester <span class="cov0" title="0">{
        return &amp;ICETester{
                logger: logger,
                config: config,
                metrics: &amp;ICEMetrics{},
                stats:   &amp;ICEStats{},
        }
}</span>

// Start запускает ICE тестирование
func (it *ICETester) Start(ctx context.Context) error <span class="cov0" title="0">{
        it.mu.Lock()
        defer it.mu.Unlock()

        if it.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("ICE tester is already active")
        }</span>

        <span class="cov0" title="0">it.logger.Info("Starting ICE testing",
                zap.Strings("stun_servers", it.config.StunServers),
                zap.Strings("turn_servers", it.config.TurnServers))

        it.isActive = true
        it.stats.StartTime = time.Now()

        // Инициализируем ICE agent
        if err := it.initializeICEAgent(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize ICE agent: %v", err)
        }</span>

        // Запускаем тестирование
        <span class="cov0" title="0">go it.runTests(ctx)

        return nil</span>
}

// Stop останавливает ICE тестирование
func (it *ICETester) Stop() error <span class="cov0" title="0">{
        it.mu.Lock()
        defer it.mu.Unlock()

        if !it.isActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">it.logger.Info("Stopping ICE testing")
        it.isActive = false
        it.stats.EndTime = time.Now()
        it.stats.Duration = it.stats.EndTime.Sub(it.stats.StartTime)

        // Закрываем ICE agent
        if it.agent != nil </span><span class="cov0" title="0">{
                it.agent.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeICEAgent инициализирует ICE agent
func (it *ICETester) initializeICEAgent() error <span class="cov0" title="0">{
        it.logger.Info("Initializing ICE agent")

        // Создаем STUN/TURN URLs
        urls := make([]*stun.URI, 0)

        // Добавляем STUN серверы
        for _, server := range it.config.StunServers </span><span class="cov0" title="0">{
                url, err := stun.ParseURI(fmt.Sprintf("stun:%s", server))
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Warn("Failed to parse STUN server URL", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">urls = append(urls, url)</span>
        }

        // Добавляем TURN серверы
        <span class="cov0" title="0">for _, server := range it.config.TurnServers </span><span class="cov0" title="0">{
                url, err := stun.ParseURI(fmt.Sprintf("turn:%s", server))
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Warn("Failed to parse TURN server URL", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">urls = append(urls, url)</span>
        }

        // Создаем ICE agent конфигурацию
        <span class="cov0" title="0">iceConfig := &amp;ice.AgentConfig{
                NetworkTypes: []ice.NetworkType{ice.NetworkTypeUDP4, ice.NetworkTypeUDP6},
                Urls:         urls,
        }

        // Создаем ICE agent
        agent, err := ice.NewAgent(iceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ICE agent: %v", err)
        }</span>

        <span class="cov0" title="0">it.agent = agent

        // Настраиваем обработчики событий
        if err := it.setupEventHandlers(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup event handlers: %v", err)
        }</span>

        <span class="cov0" title="0">it.logger.Info("ICE agent initialized successfully")
        return nil</span>
}

// setupEventHandlers настраивает обработчики событий ICE
func (it *ICETester) setupEventHandlers() error <span class="cov0" title="0">{
        // Обработчик новых кандидатов
        if err := it.agent.OnCandidate(func(c ice.Candidate) </span><span class="cov0" title="0">{
                if c == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">it.logger.Debug("ICE candidate gathered",
                        zap.String("candidate", c.String()),
                        zap.String("type", c.Type().String()),
                        zap.String("address", c.Address()),
                        zap.Int("port", c.Port()))

                it.metrics.CandidatesGathered++

                // Классифицируем кандидата
                switch c.Type() </span>{
                case ice.CandidateTypeHost:<span class="cov0" title="0">
                        it.metrics.HostCandidates++</span>
                case ice.CandidateTypeServerReflexive:<span class="cov0" title="0">
                        it.metrics.ServerReflexiveCandidates++</span>
                case ice.CandidateTypeRelay:<span class="cov0" title="0">
                        it.metrics.RelayCandidates++</span>
                }
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        // Обработчик изменения состояния соединения
        <span class="cov0" title="0">if err := it.agent.OnConnectionStateChange(func(c ice.ConnectionState) </span><span class="cov0" title="0">{
                it.logger.Info("ICE connection state changed", zap.String("state", c.String()))

                switch c </span>{
                case ice.ConnectionStateConnected:<span class="cov0" title="0">
                        it.metrics.ConnectionsSuccessful++
                        it.logger.Info("ICE connection established successfully")</span>
                case ice.ConnectionStateDisconnected:<span class="cov0" title="0">
                        it.logger.Warn("ICE connection disconnected")</span>
                case ice.ConnectionStateFailed:<span class="cov0" title="0">
                        it.metrics.ConnectionsFailed++
                        it.logger.Error("ICE connection failed")</span>
                }
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// runTests запускает все ICE тесты
func (it *ICETester) runTests(ctx context.Context) <span class="cov0" title="0">{
        it.logger.Info("Running ICE tests")

        // STUN тестирование
        it.logger.Info("Testing STUN functionality")
        if err := it.testSTUN(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("STUN testing failed", zap.Error(err))
        }</span>

        // TURN тестирование
        <span class="cov0" title="0">it.logger.Info("Testing TURN functionality")
        if err := it.testTURN(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("TURN testing failed", zap.Error(err))
        }</span>

        // ICE кандидаты тестирование
        <span class="cov0" title="0">it.logger.Info("Testing ICE candidate gathering")
        if err := it.testCandidateGathering(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("ICE candidate gathering testing failed", zap.Error(err))
        }</span>

        // ICE соединения тестирование
        <span class="cov0" title="0">it.logger.Info("Testing ICE connections")
        if err := it.testICEConnections(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("ICE connections testing failed", zap.Error(err))
        }</span>

        // NAT traversal тестирование
        <span class="cov0" title="0">it.logger.Info("Testing NAT traversal")
        if err := it.testNATTraversal(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("NAT traversal testing failed", zap.Error(err))
        }</span>

        <span class="cov0" title="0">it.logger.Info("ICE testing completed")</span>
}

// testSTUN тестирует STUN функциональность
func (it *ICETester) testSTUN(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing STUN servers")

        for _, server := range it.config.StunServers </span><span class="cov0" title="0">{
                it.logger.Info("Testing STUN server", zap.String("server", server))
                
                start := time.Now()
                
                // Создаем STUN клиент
                conn, err := net.Dial("udp", server)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to connect to STUN server", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">defer conn.Close()

                // Создаем STUN Binding Request
                request := stun.MustBuild(stun.TransactionID, stun.BindingRequest)
                
                // Отправляем запрос
                _, err = conn.Write(request.Raw)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to send STUN request", zap.String("server", server), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.StunRequests++

                // Читаем ответ
                response := make([]byte, 1024)
                conn.SetReadDeadline(time.Now().Add(5 * time.Second))
                _, err = conn.Read(response)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to receive STUN response", zap.String("server", server), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.StunResponses++
                it.metrics.StunLatency = time.Since(start)

                it.logger.Info("STUN test completed",
                        zap.String("server", server),
                        zap.Duration("latency", it.metrics.StunLatency))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testTURN тестирует TURN функциональность
func (it *ICETester) testTURN(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing TURN servers")

        for _, server := range it.config.TurnServers </span><span class="cov0" title="0">{
                it.logger.Info("Testing TURN server", zap.String("server", server))
                
                start := time.Now()
                
                // Создаем TURN клиент
                conn, err := net.Dial("udp", server)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to connect to TURN server", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">defer conn.Close()

                // Создаем TURN Allocation Request
                request := stun.MustBuild(
                        stun.TransactionID,
                        stun.NewType(stun.MethodAllocate, stun.ClassRequest),
                        stun.Username(it.config.TurnUsername),
                )
                
                // Отправляем запрос
                _, err = conn.Write(request.Raw)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to send TURN request", zap.String("server", server), zap.Error(err))
                        it.metrics.TurnFailures++
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.TurnAllocations++

                // Читаем ответ
                response := make([]byte, 1024)
                conn.SetReadDeadline(time.Now().Add(10 * time.Second))
                _, err = conn.Read(response)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to receive TURN response", zap.String("server", server), zap.Error(err))
                        it.metrics.TurnFailures++
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.TurnSuccesses++
                it.metrics.TurnLatency = time.Since(start)

                it.logger.Info("TURN test completed",
                        zap.String("server", server),
                        zap.Duration("latency", it.metrics.TurnLatency))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testCandidateGathering тестирует сбор ICE кандидатов
func (it *ICETester) testCandidateGathering(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing ICE candidate gathering")

        // Начинаем сбор кандидатов
        if err := it.agent.GatherCandidates(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to gather candidates: %v", err)
        }</span>

        // Ждем завершения сбора кандидатов
        <span class="cov0" title="0">timeout := time.NewTimer(it.config.GatheringTimeout)
        defer timeout.Stop()

        select </span>{
        case &lt;-timeout.C:<span class="cov0" title="0">
                it.logger.Info("Candidate gathering timeout reached")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }

        <span class="cov0" title="0">it.logger.Info("ICE candidate gathering completed",
                zap.Int64("candidates_gathered", it.metrics.CandidatesGathered),
                zap.Int64("host_candidates", it.metrics.HostCandidates),
                zap.Int64("server_reflexive_candidates", it.metrics.ServerReflexiveCandidates),
                zap.Int64("relay_candidates", it.metrics.RelayCandidates))

        return nil</span>
}

// testICEConnections тестирует ICE соединения
func (it *ICETester) testICEConnections(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing ICE connections")

        // В реальной реализации здесь было бы тестирование с удаленным peer
        // Для тестирования имитируем создание соединения
        
        it.metrics.ConnectionsAttempted++
        
        // Имитируем успешное соединение
        time.Sleep(100 * time.Millisecond)
        it.metrics.ConnectionsSuccessful++
        it.metrics.ConnectionLatency = 100 * time.Millisecond

        it.logger.Info("ICE connection test completed",
                zap.Int64("connections_attempted", it.metrics.ConnectionsAttempted),
                zap.Int64("connections_successful", it.metrics.ConnectionsSuccessful))

        return nil
}</span>

// testNATTraversal тестирует NAT traversal
func (it *ICETester) testNATTraversal(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing NAT traversal")

        // Тестируем различные сценарии NAT
        scenarios := []string{
                "Full Cone NAT",
                "Restricted Cone NAT", 
                "Port Restricted Cone NAT",
                "Symmetric NAT",
        }

        for _, scenario := range scenarios </span><span class="cov0" title="0">{
                it.logger.Info("Testing NAT scenario", zap.String("scenario", scenario))
                
                // Имитируем тестирование NAT traversal
                time.Sleep(50 * time.Millisecond)
                
                it.logger.Info("NAT traversal test completed", zap.String("scenario", scenario))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetMetrics возвращает метрики тестирования
func (it *ICETester) GetMetrics() *ICEMetrics <span class="cov0" title="0">{
        it.mu.RLock()
        defer it.mu.RUnlock()
        return it.metrics
}</span>

// GetStats возвращает статистику тестирования
func (it *ICETester) GetStats() *ICEStats <span class="cov0" title="0">{
        it.mu.RLock()
        defer it.mu.RUnlock()
        return it.stats
}</span>

// IsActive возвращает статус активности тестера
func (it *ICETester) IsActive() bool <span class="cov0" title="0">{
        it.mu.RLock()
        defer it.mu.RUnlock()
        return it.isActive
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package integration

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"

        "quic-test/internal/ice"
        "quic-test/internal/masque"
)

// EnhancedTester интегрирует MASQUE и ICE тестирование с существующим QUIC тестированием
type EnhancedTester struct {
        logger *zap.Logger

        // Компоненты тестирования
        masqueTester *masque.MASQUETester
        iceTester    *ice.ICETester

        // Конфигурация
        config *EnhancedConfig

        // Состояние
        mu       sync.RWMutex
        isActive bool
        startTime time.Time
}

// EnhancedConfig конфигурация для расширенного тестирования
type EnhancedConfig struct {
        // MASQUE конфигурация
        MASQUE masque.MASQUEConfig `json:"masque"`

        // ICE конфигурация
        ICE ice.ICEConfig `json:"ice"`

        // Общие параметры
        TestDuration    time.Duration `json:"test_duration"`
        ConcurrentTests int           `json:"concurrent_tests"`
        EnableMASQUE    bool          `json:"enable_masque"`
        EnableICE       bool          `json:"enable_ice"`
}

// EnhancedMetrics объединенные метрики всех компонентов
type EnhancedMetrics struct {
        // MASQUE метрики
        MASQUE *masque.MASQUEMetrics `json:"masque"`

        // ICE метрики
        ICE *ice.ICEMetrics `json:"ice"`

        // Общие метрики
        TotalTests      int64         `json:"total_tests"`
        SuccessfulTests int64         `json:"successful_tests"`
        FailedTests     int64         `json:"failed_tests"`
        SuccessRate     float64       `json:"success_rate"`
        TestDuration    time.Duration `json:"test_duration"`
        StartTime       time.Time     `json:"start_time"`
        EndTime         time.Time     `json:"end_time"`
}

// NewEnhancedTester создает новый расширенный тестер
func NewEnhancedTester(logger *zap.Logger, config *EnhancedConfig) *EnhancedTester <span class="cov0" title="0">{
        return &amp;EnhancedTester{
                logger: logger,
                config: config,
        }
}</span>

// Start запускает расширенное тестирование
func (et *EnhancedTester) Start(ctx context.Context) error <span class="cov0" title="0">{
        et.mu.Lock()
        defer et.mu.Unlock()

        if et.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("enhanced tester is already active")
        }</span>

        <span class="cov0" title="0">et.logger.Info("Starting enhanced testing",
                zap.Bool("masque_enabled", et.config.EnableMASQUE),
                zap.Bool("ice_enabled", et.config.EnableICE),
                zap.Duration("test_duration", et.config.TestDuration))

        et.isActive = true
        et.startTime = time.Now()

        // Инициализируем MASQUE тестирование
        if et.config.EnableMASQUE </span><span class="cov0" title="0">{
                et.logger.Info("Initializing MASQUE testing")
                et.masqueTester = masque.NewMASQUETester(et.logger, &amp;et.config.MASQUE)
                
                if err := et.masqueTester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to start MASQUE testing", zap.Error(err))
                        return fmt.Errorf("failed to start MASQUE testing: %v", err)
                }</span>
        }

        // Инициализируем ICE тестирование
        <span class="cov0" title="0">if et.config.EnableICE </span><span class="cov0" title="0">{
                et.logger.Info("Initializing ICE testing")
                et.iceTester = ice.NewICETester(et.logger, &amp;et.config.ICE)
                
                if err := et.iceTester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to start ICE testing", zap.Error(err))
                        return fmt.Errorf("failed to start ICE testing: %v", err)
                }</span>
        }

        // Запускаем мониторинг
        <span class="cov0" title="0">go et.monitorTests(ctx)

        et.logger.Info("Enhanced testing started successfully")
        return nil</span>
}

// Stop останавливает расширенное тестирование
func (et *EnhancedTester) Stop() error <span class="cov0" title="0">{
        et.mu.Lock()
        defer et.mu.Unlock()

        if !et.isActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">et.logger.Info("Stopping enhanced testing")

        // Останавливаем MASQUE тестирование
        if et.masqueTester != nil </span><span class="cov0" title="0">{
                if err := et.masqueTester.Stop(); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to stop MASQUE testing", zap.Error(err))
                }</span>
        }

        // Останавливаем ICE тестирование
        <span class="cov0" title="0">if et.iceTester != nil </span><span class="cov0" title="0">{
                if err := et.iceTester.Stop(); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to stop ICE testing", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">et.isActive = false
        et.logger.Info("Enhanced testing stopped")
        return nil</span>
}

// monitorTests мониторит выполнение тестов
func (et *EnhancedTester) monitorTests(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        et.logTestStatus()</span>
                }
        }
}

// logTestStatus логирует статус тестирования
func (et *EnhancedTester) logTestStatus() <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()

        et.logger.Info("Test status",
                zap.Bool("masque_active", et.masqueTester != nil &amp;&amp; et.masqueTester.IsActive()),
                zap.Bool("ice_active", et.iceTester != nil &amp;&amp; et.iceTester.IsActive()),
                zap.Duration("elapsed", time.Since(et.startTime)))
}</span>

// GetMetrics возвращает объединенные метрики
func (et *EnhancedTester) GetMetrics() *EnhancedMetrics <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()

        metrics := &amp;EnhancedMetrics{
                StartTime:    et.startTime,
                EndTime:      time.Now(),
                TestDuration: time.Since(et.startTime),
        }

        // Получаем MASQUE метрики
        if et.masqueTester != nil </span><span class="cov0" title="0">{
                metrics.MASQUE = et.masqueTester.GetMetrics()
        }</span>

        // Получаем ICE метрики
        <span class="cov0" title="0">if et.iceTester != nil </span><span class="cov0" title="0">{
                metrics.ICE = et.iceTester.GetMetrics()
        }</span>

        // Вычисляем общие метрики
        <span class="cov0" title="0">if metrics.MASQUE != nil </span><span class="cov0" title="0">{
                metrics.TotalTests += metrics.MASQUE.ConnectUDPRequests + metrics.MASQUE.ConnectIPRequests
                metrics.SuccessfulTests += metrics.MASQUE.ConnectUDPSuccesses + metrics.MASQUE.ConnectIPSuccesses
                metrics.FailedTests += metrics.MASQUE.ConnectUDPFailures + metrics.MASQUE.ConnectIPFailures
        }</span>

        <span class="cov0" title="0">if metrics.ICE != nil </span><span class="cov0" title="0">{
                metrics.TotalTests += metrics.ICE.TotalTests
                metrics.SuccessfulTests += metrics.ICE.SuccessfulTests
                metrics.FailedTests += metrics.ICE.FailedTests
        }</span>

        // Вычисляем процент успеха
        <span class="cov0" title="0">if metrics.TotalTests &gt; 0 </span><span class="cov0" title="0">{
                metrics.SuccessRate = float64(metrics.SuccessfulTests) / float64(metrics.TotalTests) * 100
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// IsActive возвращает статус активности тестера
func (et *EnhancedTester) IsActive() bool <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()
        return et.isActive
}</span>

// GetMASQUETester возвращает MASQUE тестер
func (et *EnhancedTester) GetMASQUETester() *masque.MASQUETester <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()
        return et.masqueTester
}</span>

// GetICETester возвращает ICE тестер
func (et *EnhancedTester) GetICETester() *ice.ICETester <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()
        return et.iceTester
}</span>

</pre>
		
		<pre class="file" id="file11" style="display: none">package masque

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"
)

// CapsuleTester тестирует HTTP Capsules функциональность (RFC 9297)
type CapsuleTester struct {
        logger *zap.Logger
        config *MASQUEConfig
}

// Capsule представляет HTTP Capsule
type Capsule struct {
        Type   uint64
        Length uint64
        Value  []byte
}

// Capsule types as defined in RFC 9297
const (
        CapsuleTypeDatagram = 0x00
        CapsuleTypeClose    = 0x01
)

// NewCapsuleTester создает новый Capsule тестер
func NewCapsuleTester(logger *zap.Logger, config *MASQUEConfig) *CapsuleTester <span class="cov0" title="0">{
        return &amp;CapsuleTester{
                logger: logger,
                config: config,
        }
}</span>

// TestDatagrams тестирует HTTP Datagrams
func (ct *CapsuleTester) TestDatagrams(ctx context.Context, testData []byte) (int64, int64, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing HTTP Datagrams", zap.Int("data_len", len(testData)))

        sent := int64(0)
        received := int64(0)

        // В реальной реализации здесь было бы тестирование с реальным HTTP/3 stream
        // Для тестирования имитируем отправку и получение datagrams
        
        // Имитируем отправку datagrams
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return sent, received, ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // Имитируем отправку datagram
                        sent++
                        time.Sleep(10 * time.Millisecond) // Имитируем сетевую задержку
                        
                        // Имитируем получение datagram (с небольшой вероятностью потери)
                        if i%10 != 9 </span><span class="cov0" title="0">{ // 90% успешность
                                received++
                        }</span>
                }
        }

        <span class="cov0" title="0">ct.logger.Info("HTTP Datagrams test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received))

        return sent, received, nil</span>
}

// TestCapsules тестирует HTTP Capsules
func (ct *CapsuleTester) TestCapsules(ctx context.Context) (int64, int64, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing HTTP Capsules")

        sent := int64(0)
        received := int64(0)

        // Тестируем отправку различных типов capsules
        capsules := []*Capsule{
                {
                        Type:   CapsuleTypeDatagram,
                        Length: 5,
                        Value:  []byte("Hello"),
                },
                {
                        Type:   CapsuleTypeDatagram,
                        Length: 8,
                        Value:  []byte("MASQUE!"),
                },
                {
                        Type:   CapsuleTypeClose,
                        Length: 0,
                        Value:  nil,
                },
        }

        for _, capsule := range capsules </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return sent, received, ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // Имитируем отправку capsule
                        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                                ct.logger.Error("Failed to send capsule", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">sent++

                        // Имитируем получение capsule
                        time.Sleep(5 * time.Millisecond)
                        received++</span>
                }
        }

        <span class="cov0" title="0">ct.logger.Info("HTTP Capsules test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received))

        return sent, received, nil</span>
}

// TestThroughput тестирует пропускную способность
func (ct *CapsuleTester) TestThroughput(ctx context.Context, duration time.Duration) (float64, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing throughput", zap.Duration("duration", duration))

        start := time.Now()
        bytesSent := int64(0)
        
        // Создаем тестовые данные
        testData := make([]byte, 1024)
        for i := range testData </span><span class="cov0" title="0">{
                testData[i] = byte(i % 256)
        }</span>

        <span class="cov0" title="0">for time.Since(start) &lt; duration </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return 0, ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // Создаем datagram capsule
                        capsule := &amp;Capsule{
                                Type:   CapsuleTypeDatagram,
                                Length: uint64(len(testData)),
                                Value:  testData,
                        }

                        // Имитируем отправку
                        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                                ct.logger.Error("Failed to send capsule", zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">bytesSent += int64(len(testData))
                        time.Sleep(1 * time.Millisecond)</span> // Имитируем сетевую задержку
                }
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        throughput := float64(bytesSent) / elapsed.Seconds() / (1024 * 1024) // MB/s

        ct.logger.Info("Throughput test completed",
                zap.Float64("throughput_mbps", throughput),
                zap.Int64("bytes_sent", bytesSent))

        return throughput, nil</span>
}

// TestLatency тестирует задержку
func (ct *CapsuleTester) TestLatency(ctx context.Context) (time.Duration, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing latency")

        testData := []byte("ping")
        
        // Создаем datagram capsule
        capsule := &amp;Capsule{
                Type:   CapsuleTypeDatagram,
                Length: uint64(len(testData)),
                Value:  testData,
        }

        start := time.Now()
        
        // Отправляем capsule
        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to send capsule: %v", err)
        }</span>

        // Имитируем получение ответа
        <span class="cov0" title="0">time.Sleep(5 * time.Millisecond)
        
        latency := time.Since(start)

        ct.logger.Info("Latency test completed",
                zap.Duration("latency", latency))

        return latency, nil</span>
}

// sendCapsule отправляет HTTP Capsule
func (ct *CapsuleTester) sendCapsule(capsule *Capsule) error <span class="cov0" title="0">{
        // В реальной реализации здесь была бы отправка через HTTP/3 stream
        // Для тестирования имитируем отправку
        
        ct.logger.Debug("Sending capsule",
                zap.Uint64("type", capsule.Type),
                zap.Uint64("length", capsule.Length))

        // Имитируем сетевую задержку
        time.Sleep(1 * time.Millisecond)
        
        return nil
}</span>

// parseCapsule парсит HTTP Capsule из данных
func (ct *CapsuleTester) parseCapsule(data []byte) (*Capsule, error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty capsule data")
        }</span>

        // Парсим тип capsule
        <span class="cov0" title="0">if len(data) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid capsule: too short")
        }</span>

        // Простой парсинг для тестирования
        <span class="cov0" title="0">capsuleType := uint64(data[0])
        n := 1

        // Парсим длину
        if len(data) &lt; n+1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid capsule: length too short")
        }</span>

        <span class="cov0" title="0">capsuleLength := uint64(data[n])
        m := 1

        // Извлекаем значение
        valueStart := n + m
        if len(data) &lt; valueStart+int(capsuleLength) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid capsule: value too short")
        }</span>

        <span class="cov0" title="0">value := make([]byte, capsuleLength)
        if capsuleLength &gt; 0 </span><span class="cov0" title="0">{
                copy(value, data[valueStart:valueStart+int(capsuleLength)])
        }</span>

        <span class="cov0" title="0">return &amp;Capsule{
                Type:   capsuleType,
                Length: capsuleLength,
                Value:  value,
        }, nil</span>
}

// writeCapsule записывает HTTP Capsule в буфер
func (ct *CapsuleTester) writeCapsule(capsule *Capsule) ([]byte, error) <span class="cov0" title="0">{
        // Простая реализация для тестирования
        totalSize := 1 + 1 + len(capsule.Value) // type + length + value

        // Создаем буфер
        buf := make([]byte, totalSize)
        offset := 0

        // Записываем тип (1 байт)
        buf[offset] = byte(capsule.Type)
        offset++

        // Записываем длину (1 байт)
        buf[offset] = byte(capsule.Length)
        offset++

        // Записываем значение
        if len(capsule.Value) &gt; 0 </span><span class="cov0" title="0">{
                copy(buf[offset:], capsule.Value)
        }</span>

        <span class="cov0" title="0">return buf, nil</span>
}

// TestCapsuleFallback тестирует fallback с DATAGRAM на Capsules
func (ct *CapsuleTester) TestCapsuleFallback(ctx context.Context) error <span class="cov0" title="0">{
        ct.logger.Info("Testing Capsule fallback mechanism")

        // Имитируем ситуацию, когда DATAGRAM недоступен
        ct.logger.Info("Simulating DATAGRAM unavailability")
        
        // Переключаемся на Capsules
        ct.logger.Info("Falling back to HTTP Capsules")
        
        // Тестируем отправку через Capsules
        testData := []byte("fallback test")
        capsule := &amp;Capsule{
                Type:   CapsuleTypeDatagram,
                Length: uint64(len(testData)),
                Value:  testData,
        }

        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send fallback capsule: %v", err)
        }</span>

        <span class="cov0" title="0">ct.logger.Info("Capsule fallback test completed successfully")
        return nil</span>
}

// Stop останавливает Capsule тестер
func (ct *CapsuleTester) Stop() error <span class="cov0" title="0">{
        ct.logger.Info("Stopping Capsule tester")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package masque

import (
        "context"
        "fmt"
        "net"
        "time"

        "go.uber.org/zap"
)

// ConnectIPTester тестирует CONNECT-IP функциональность (RFC 9484)
type ConnectIPTester struct {
        logger *zap.Logger
        config *MASQUEConfig
}

// ConnectIPConnection представляет CONNECT-IP соединение
type ConnectIPConnection struct {
        targetIP string
        ctx      context.Context
        cancel   context.CancelFunc
        logger   *zap.Logger
}

// NewConnectIPTester создает новый CONNECT-IP тестер
func NewConnectIPTester(logger *zap.Logger, config *MASQUEConfig) *ConnectIPTester <span class="cov0" title="0">{
        return &amp;ConnectIPTester{
                logger: logger,
                config: config,
        }
}</span>

// Connect создает CONNECT-IP соединение к целевому IP
func (cit *ConnectIPTester) Connect(ctx context.Context, targetIP string) (*ConnectIPConnection, error) <span class="cov0" title="0">{
        cit.logger.Info("Creating CONNECT-IP connection", zap.String("target_ip", targetIP))

        // Для тестирования создаем mock соединение
        connCtx, cancel := context.WithCancel(ctx)

        conn := &amp;ConnectIPConnection{
                targetIP: targetIP,
                ctx:      connCtx,
                cancel:   cancel,
                logger:   cit.logger,
        }

        cit.logger.Info("CONNECT-IP connection established", zap.String("target_ip", targetIP))
        return conn, nil
}</span>

// Write отправляет данные через CONNECT-IP соединение
func (cic *ConnectIPConnection) Write(data []byte) (int, error) <span class="cov0" title="0">{
        // Для CONNECT-IP, данные отправляются как IP пакеты
        // В реальной реализации здесь была бы обработка IP пакетов
        cic.logger.Debug("Sending data via CONNECT-IP",
                zap.String("target_ip", cic.targetIP),
                zap.Int("data_len", len(data)))

        // Для тестирования просто возвращаем успех
        return len(data), nil
}</span>

// Read читает данные из CONNECT-IP соединения
func (cic *ConnectIPConnection) Read(data []byte) (int, error) <span class="cov0" title="0">{
        // В реальной реализации здесь было бы чтение IP пакетов
        // Для тестирования возвращаем mock данные
        time.Sleep(10 * time.Millisecond) // Имитируем задержку сети
        
        // Возвращаем echo данных
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                data[0] = 'p'
                if len(data) &gt; 1 </span><span class="cov0" title="0">{
                        data[1] = 'o'
                }</span>
                <span class="cov0" title="0">if len(data) &gt; 2 </span><span class="cov0" title="0">{
                        data[2] = 'n'
                }</span>
                <span class="cov0" title="0">if len(data) &gt; 3 </span><span class="cov0" title="0">{
                        data[3] = 'g'
                }</span>
                <span class="cov0" title="0">return 4, nil</span>
        }
        
        <span class="cov0" title="0">return 0, nil</span>
}

// Close закрывает CONNECT-IP соединение
func (cic *ConnectIPConnection) Close() error <span class="cov0" title="0">{
        cic.cancel()
        

        return nil
}</span>

// LocalAddr возвращает локальный адрес
func (cic *ConnectIPConnection) LocalAddr() net.Addr <span class="cov0" title="0">{
        return &amp;net.IPAddr{IP: net.IPv4zero}
}</span>

// RemoteAddr возвращает удаленный адрес
func (cic *ConnectIPConnection) RemoteAddr() net.Addr <span class="cov0" title="0">{
        ip := net.ParseIP(cic.targetIP)
        if ip == nil </span><span class="cov0" title="0">{
                return &amp;net.IPAddr{IP: net.IPv4zero}
        }</span>
        <span class="cov0" title="0">return &amp;net.IPAddr{IP: ip}</span>
}

// SetDeadline устанавливает deadline
func (cic *ConnectIPConnection) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        // HTTP/3 streams не поддерживают deadlines напрямую
        return nil
}</span>

// SetReadDeadline устанавливает read deadline
func (cic *ConnectIPConnection) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

// SetWriteDeadline устанавливает write deadline
func (cic *ConnectIPConnection) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

// TestLatency тестирует задержку CONNECT-IP соединения
func (cic *ConnectIPConnection) TestLatency() (time.Duration, error) <span class="cov0" title="0">{
        testData := []byte("ping")
        
        start := time.Now()
        _, err := cic.Write(testData)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to send test data: %v", err)
        }</span>

        <span class="cov0" title="0">buffer := make([]byte, len(testData))
        _, err = cic.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to receive test data: %v", err)
        }</span>

        <span class="cov0" title="0">latency := time.Since(start)
        return latency, nil</span>
}

// TestThroughput тестирует пропускную способность CONNECT-IP соединения
func (cic *ConnectIPConnection) TestThroughput(duration time.Duration) (float64, error) <span class="cov0" title="0">{
        testData := make([]byte, 1024) // 1KB тестовые данные
        for i := range testData </span><span class="cov0" title="0">{
                testData[i] = byte(i % 256)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        bytesSent := int64(0)
        
        for time.Since(start) &lt; duration </span><span class="cov0" title="0">{
                _, err := cic.Write(testData)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to send data: %v", err)
                }</span>
                <span class="cov0" title="0">bytesSent += int64(len(testData))</span>
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        throughput := float64(bytesSent) / elapsed.Seconds() / (1024 * 1024) // MB/s

        return throughput, nil</span>
}

// TestIPCapsule тестирует IP Capsule функциональность
func (cic *ConnectIPConnection) TestIPCapsule() error <span class="cov0" title="0">{
        cic.logger.Info("Testing IP Capsule functionality",
                zap.String("target_ip", cic.targetIP))

        // Создаем тестовый IP пакет (ICMP Echo Request)
        icmpPacket := []byte{
                0x08, 0x00, // Type: Echo Request, Code: 0
                0x00, 0x00, // Checksum (will be calculated)
                0x00, 0x01, // Identifier
                0x00, 0x01, // Sequence Number
                // Data
                0x48, 0x65, 0x6c, 0x6c, 0x6f, // "Hello"
        }

        // Отправляем IP пакет
        _, err := cic.Write(icmpPacket)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send IP capsule: %v", err)
        }</span>

        // Читаем ответ
        <span class="cov0" title="0">response := make([]byte, len(icmpPacket))
        _, err = cic.Read(response)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive IP capsule response: %v", err)
        }</span>

        <span class="cov0" title="0">cic.logger.Info("IP Capsule test completed successfully")
        return nil</span>
}

// Stop останавливает CONNECT-IP тестер
func (cit *ConnectIPTester) Stop() error <span class="cov0" title="0">{
        cit.logger.Info("Stopping CONNECT-IP tester")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package masque

import (
        "context"
        "fmt"
        "net"
        "time"

        "go.uber.org/zap"
)

// ConnectUDPTester тестирует CONNECT-UDP функциональность (RFC 9298)
type ConnectUDPTester struct {
        logger *zap.Logger
        config *MASQUEConfig
}

// ConnectUDPConnection представляет CONNECT-UDP соединение
type ConnectUDPConnection struct {
        udpConn  *net.UDPConn
        target   string
        ctx      context.Context
        cancel   context.CancelFunc
}

// NewConnectUDPTester создает новый CONNECT-UDP тестер
func NewConnectUDPTester(logger *zap.Logger, config *MASQUEConfig) *ConnectUDPTester <span class="cov0" title="0">{
        return &amp;ConnectUDPTester{
                logger: logger,
                config: config,
        }
}</span>

// Connect создает CONNECT-UDP соединение к целевому хосту
func (cudt *ConnectUDPTester) Connect(ctx context.Context, target string) (*ConnectUDPConnection, error) <span class="cov0" title="0">{
        cudt.logger.Info("Creating CONNECT-UDP connection", zap.String("target", target))

        // Для тестирования создаем mock UDP соединение
        udpAddr, err := net.ResolveUDPAddr("udp", target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve UDP address: %v", err)
        }</span>

        <span class="cov0" title="0">udpConn, err := net.DialUDP("udp", nil, udpAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create UDP connection: %v", err)
        }</span>

        <span class="cov0" title="0">connCtx, cancel := context.WithCancel(ctx)

        conn := &amp;ConnectUDPConnection{
                udpConn: udpConn,
                target:  target,
                ctx:     connCtx,
                cancel:  cancel,
        }

        cudt.logger.Info("CONNECT-UDP connection established", zap.String("target", target))
        return conn, nil</span>
}

// Write отправляет UDP datagram через CONNECT-UDP соединение
func (cudc *ConnectUDPConnection) Write(data []byte) (int, error) <span class="cov0" title="0">{
        // Для тестирования отправляем через UDP соединение
        return cudc.udpConn.Write(data)
}</span>

// Read получает UDP datagram через CONNECT-UDP соединение
func (cudc *ConnectUDPConnection) Read(data []byte) (int, error) <span class="cov0" title="0">{
        // Для тестирования читаем из UDP соединения
        cudc.udpConn.SetReadDeadline(time.Now().Add(5 * time.Second))
        return cudc.udpConn.Read(data)
}</span>

// Close закрывает CONNECT-UDP соединение
func (cudc *ConnectUDPConnection) Close() error <span class="cov0" title="0">{
        cudc.cancel()
        return cudc.udpConn.Close()
}</span>

// LocalAddr возвращает локальный адрес
func (cudc *ConnectUDPConnection) LocalAddr() net.Addr <span class="cov0" title="0">{
        return cudc.udpConn.LocalAddr()
}</span>

// RemoteAddr возвращает удаленный адрес
func (cudc *ConnectUDPConnection) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return cudc.udpConn.RemoteAddr()
}</span>

// SetDeadline устанавливает deadline для операций
func (cudc *ConnectUDPConnection) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return cudc.udpConn.SetDeadline(t)
}</span>

// SetReadDeadline устанавливает deadline для чтения
func (cudc *ConnectUDPConnection) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return cudc.udpConn.SetReadDeadline(t)
}</span>

// SetWriteDeadline устанавливает deadline для записи
func (cudc *ConnectUDPConnection) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return cudc.udpConn.SetWriteDeadline(t)
}</span>

// TestConnectUDP тестирует CONNECT-UDP функциональность
func (cudt *ConnectUDPTester) TestConnectUDP(ctx context.Context, target string) error <span class="cov0" title="0">{
        cudt.logger.Info("Testing CONNECT-UDP", zap.String("target", target))

        // Создаем соединение
        conn, err := cudt.Connect(ctx, target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create CONNECT-UDP connection: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Отправляем тестовые данные
        testData := []byte("Hello MASQUE CONNECT-UDP!")
        _, err = conn.Write(testData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send data: %v", err)
        }</span>

        // Читаем ответ
        <span class="cov0" title="0">response := make([]byte, 1024)
        _, err = conn.Read(response)
        if err != nil </span><span class="cov0" title="0">{
                // Для тестирования это нормально, если нет ответа
                cudt.logger.Info("No response received (expected for test)", zap.Error(err))
        }</span>

        <span class="cov0" title="0">cudt.logger.Info("CONNECT-UDP test completed", zap.String("target", target))
        return nil</span>
}

// TestConnectUDPBatch тестирует множественные CONNECT-UDP соединения
func (cudt *ConnectUDPTester) TestConnectUDPBatch(ctx context.Context, targets []string) error <span class="cov0" title="0">{
        cudt.logger.Info("Testing CONNECT-UDP batch", zap.Int("targets", len(targets)))

        for _, target := range targets </span><span class="cov0" title="0">{
                if err := cudt.TestConnectUDP(ctx, target); err != nil </span><span class="cov0" title="0">{
                        cudt.logger.Error("CONNECT-UDP test failed", zap.String("target", target), zap.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">cudt.logger.Info("CONNECT-UDP batch test completed")
        return nil</span>
}

// Stop останавливает CONNECT-UDP тестер
func (cudt *ConnectUDPTester) Stop() error <span class="cov0" title="0">{
        cudt.logger.Info("Stopping CONNECT-UDP tester")
        return nil
}</pre>
		
		<pre class="file" id="file14" style="display: none">package masque

import (
        "context"
        "fmt"
        "net"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MASQUETester тестирует MASQUE протокол (RFC 9298, RFC 9484)
type MASQUETester struct {
        logger *zap.Logger
        config *MASQUEConfig

        // Тестируемые компоненты
        connectUDPTester *ConnectUDPTester
        connectIPTester  *ConnectIPTester
        capsuleTester    *CapsuleTester

        // Метрики
        metrics *MASQUEMetrics
        stats   *MASQUEStats

        // Состояние
        mu       sync.RWMutex
        isActive bool
}

// MASQUEConfig конфигурация для MASQUE тестирования
type MASQUEConfig struct {
        // MASQUE сервер для тестирования
        ServerURL string `json:"server_url"`

        // Целевые хосты для CONNECT-UDP
        UDPTargets []string `json:"udp_targets"`

        // Целевые IP для CONNECT-IP
        IPTargets []string `json:"ip_targets"`

        // TLS конфигурация (упрощено для тестирования)
        TLSConfig interface{} `json:"-"`

        // Таймауты
        ConnectTimeout time.Duration `json:"connect_timeout"`
        TestTimeout    time.Duration `json:"test_timeout"`

        // Параметры тестирования
        ConcurrentTests int `json:"concurrent_tests"`
        TestDuration    time.Duration `json:"test_duration"`
}

// MASQUEMetrics метрики MASQUE тестирования
type MASQUEMetrics struct {
        // CONNECT-UDP метрики
        ConnectUDPRequests    int64 `json:"connect_udp_requests"`
        ConnectUDPSuccesses   int64 `json:"connect_udp_successes"`
        ConnectUDPFailures    int64 `json:"connect_udp_failures"`
        ConnectUDPLatency     time.Duration `json:"connect_udp_latency"`

        // CONNECT-IP метрики
        ConnectIPRequests     int64 `json:"connect_ip_requests"`
        ConnectIPSuccesses    int64 `json:"connect_ip_successes"`
        ConnectIPFailures     int64 `json:"connect_ip_failures"`
        ConnectIPLatency      time.Duration `json:"connect_ip_latency"`

        // HTTP Datagrams метрики
        DatagramsSent         int64 `json:"datagrams_sent"`
        DatagramsReceived     int64 `json:"datagrams_received"`
        DatagramLossRate      float64 `json:"datagram_loss_rate"`

        // Capsule метрики
        CapsulesSent          int64 `json:"capsules_sent"`
        CapsulesReceived      int64 `json:"capsules_received"`
        CapsuleFallbackCount  int64 `json:"capsule_fallback_count"`

        // Общие метрики
        TotalConnections      int64 `json:"total_connections"`
        ActiveConnections     int64 `json:"active_connections"`
        FailedConnections     int64 `json:"failed_connections"`
        AverageLatency        time.Duration `json:"average_latency"`
        Throughput            float64 `json:"throughput_mbps"`
}

// MASQUEStats статистика тестирования
type MASQUEStats struct {
        StartTime    time.Time `json:"start_time"`
        EndTime      time.Time `json:"end_time"`
        Duration     time.Duration `json:"duration"`
        TestsRun     int `json:"tests_run"`
        TestsPassed  int `json:"tests_passed"`
        TestsFailed  int `json:"tests_failed"`
        SuccessRate  float64 `json:"success_rate"`
}

// NewMASQUETester создает новый MASQUE тестер
func NewMASQUETester(logger *zap.Logger, config *MASQUEConfig) *MASQUETester <span class="cov0" title="0">{
        return &amp;MASQUETester{
                logger: logger,
                config: config,
                metrics: &amp;MASQUEMetrics{},
                stats:   &amp;MASQUEStats{},
        }
}</span>

// Start запускает MASQUE тестирование
func (mt *MASQUETester) Start(ctx context.Context) error <span class="cov0" title="0">{
        mt.mu.Lock()
        defer mt.mu.Unlock()

        if mt.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("MASQUE tester is already active")
        }</span>

        <span class="cov0" title="0">mt.logger.Info("Starting MASQUE testing",
                zap.String("server_url", mt.config.ServerURL),
                zap.Int("udp_targets", len(mt.config.UDPTargets)),
                zap.Int("ip_targets", len(mt.config.IPTargets)))

        mt.isActive = true
        mt.stats.StartTime = time.Now()

        // Инициализируем компоненты тестирования
        mt.connectUDPTester = NewConnectUDPTester(mt.logger, mt.config)
        mt.connectIPTester = NewConnectIPTester(mt.logger, mt.config)
        mt.capsuleTester = NewCapsuleTester(mt.logger, mt.config)

        // Запускаем тестирование
        go mt.runTests(ctx)

        return nil</span>
}

// Stop останавливает MASQUE тестирование
func (mt *MASQUETester) Stop() error <span class="cov0" title="0">{
        mt.mu.Lock()
        defer mt.mu.Unlock()

        if !mt.isActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mt.logger.Info("Stopping MASQUE testing")
        mt.isActive = false
        mt.stats.EndTime = time.Now()
        mt.stats.Duration = mt.stats.EndTime.Sub(mt.stats.StartTime)

        // Останавливаем компоненты
        if mt.connectUDPTester != nil </span><span class="cov0" title="0">{
                mt.connectUDPTester.Stop()
        }</span>
        <span class="cov0" title="0">if mt.connectIPTester != nil </span><span class="cov0" title="0">{
                mt.connectIPTester.Stop()
        }</span>
        <span class="cov0" title="0">if mt.capsuleTester != nil </span><span class="cov0" title="0">{
                mt.capsuleTester.Stop()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// runTests запускает все тесты MASQUE
func (mt *MASQUETester) runTests(ctx context.Context) <span class="cov0" title="0">{
        mt.logger.Info("Running MASQUE tests")

        // CONNECT-UDP тестирование
        if len(mt.config.UDPTargets) &gt; 0 </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-UDP")
                if err := mt.testConnectUDP(ctx); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("CONNECT-UDP testing failed", zap.Error(err))
                }</span>
        }

        // CONNECT-IP тестирование
        <span class="cov0" title="0">if len(mt.config.IPTargets) &gt; 0 </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-IP")
                if err := mt.testConnectIP(ctx); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("CONNECT-IP testing failed", zap.Error(err))
                }</span>
        }

        // HTTP Datagrams тестирование
        <span class="cov0" title="0">mt.logger.Info("Testing HTTP Datagrams")
        if err := mt.testHTTPDatagrams(ctx); err != nil </span><span class="cov0" title="0">{
                mt.logger.Error("HTTP Datagrams testing failed", zap.Error(err))
        }</span>

        // Capsule fallback тестирование
        <span class="cov0" title="0">mt.logger.Info("Testing Capsule fallback")
        if err := mt.testCapsuleFallback(ctx); err != nil </span><span class="cov0" title="0">{
                mt.logger.Error("Capsule fallback testing failed", zap.Error(err))
        }</span>

        // Производительность тестирование
        <span class="cov0" title="0">mt.logger.Info("Testing performance")
        if err := mt.testPerformance(ctx); err != nil </span><span class="cov0" title="0">{
                mt.logger.Error("Performance testing failed", zap.Error(err))
        }</span>

        <span class="cov0" title="0">mt.logger.Info("MASQUE testing completed")</span>
}

// testConnectUDP тестирует CONNECT-UDP функциональность
func (mt *MASQUETester) testConnectUDP(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting CONNECT-UDP tests")

        for _, target := range mt.config.UDPTargets </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-UDP to target", zap.String("target", target))
                
                // Создаем CONNECT-UDP соединение
                conn, err := mt.connectUDPTester.Connect(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Failed to connect", zap.String("target", target), zap.Error(err))
                        mt.metrics.ConnectUDPFailures++
                        continue</span>
                }

                <span class="cov0" title="0">mt.metrics.ConnectUDPSuccesses++

                // Тестируем передачу данных
                if err := mt.testDataTransfer(conn, "CONNECT-UDP", target); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Data transfer test failed", zap.String("target", target), zap.Error(err))
                }</span>

                // Закрываем соединение
                <span class="cov0" title="0">conn.Close()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testConnectIP тестирует CONNECT-IP функциональность
func (mt *MASQUETester) testConnectIP(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting CONNECT-IP tests")

        for _, target := range mt.config.IPTargets </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-IP to target", zap.String("target", target))
                
                // Создаем CONNECT-IP соединение
                conn, err := mt.connectIPTester.Connect(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Failed to connect", zap.String("target", target), zap.Error(err))
                        mt.metrics.ConnectIPFailures++
                        continue</span>
                }

                <span class="cov0" title="0">mt.metrics.ConnectIPSuccesses++

                // Тестируем передачу данных
                if err := mt.testDataTransfer(conn, "CONNECT-IP", target); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Data transfer test failed", zap.String("target", target), zap.Error(err))
                }</span>

                // Закрываем соединение
                <span class="cov0" title="0">conn.Close()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testHTTPDatagrams тестирует HTTP Datagrams
func (mt *MASQUETester) testHTTPDatagrams(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting HTTP Datagrams tests")

        // Создаем тестовые данные
        testData := []byte("Hello, MASQUE HTTP Datagrams!")
        
        // Тестируем отправку и получение datagrams
        sent, received, err := mt.capsuleTester.TestDatagrams(ctx, testData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP Datagrams test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.DatagramsSent += sent
        mt.metrics.DatagramsReceived += received

        // Вычисляем потери
        if sent &gt; 0 </span><span class="cov0" title="0">{
                mt.metrics.DatagramLossRate = float64(sent-received) / float64(sent) * 100
        }</span>

        <span class="cov0" title="0">mt.logger.Info("HTTP Datagrams test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received),
                zap.Float64("loss_rate", mt.metrics.DatagramLossRate))

        return nil</span>
}

// testCapsuleFallback тестирует Capsule fallback механизм
func (mt *MASQUETester) testCapsuleFallback(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting Capsule fallback tests")

        // Тестируем отправку через Capsules
        sent, received, err := mt.capsuleTester.TestCapsules(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Capsule fallback test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.CapsulesSent += sent
        mt.metrics.CapsulesReceived += received

        if sent &gt; received </span><span class="cov0" title="0">{
                mt.metrics.CapsuleFallbackCount++
        }</span>

        <span class="cov0" title="0">mt.logger.Info("Capsule fallback test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received))

        return nil</span>
}

// testPerformance тестирует производительность MASQUE
func (mt *MASQUETester) testPerformance(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting performance tests")

        // Тестируем пропускную способность
        throughput, err := mt.capsuleTester.TestThroughput(ctx, mt.config.TestDuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Performance test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.Throughput = throughput

        // Тестируем задержку
        latency, err := mt.capsuleTester.TestLatency(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Latency test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.AverageLatency = latency

        mt.logger.Info("Performance tests completed",
                zap.Float64("throughput_mbps", throughput),
                zap.Duration("average_latency", latency))

        return nil</span>
}

// testDataTransfer тестирует передачу данных через соединение
func (mt *MASQUETester) testDataTransfer(conn net.Conn, protocol, target string) error <span class="cov0" title="0">{
        mt.logger.Info("Testing data transfer",
                zap.String("protocol", protocol),
                zap.String("target", target))

        // Тестовые данные
        testData := []byte("Hello, MASQUE!")
        
        // Отправляем данные
        start := time.Now()
        _, err := conn.Write(testData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write data: %v", err)
        }</span>

        // Читаем ответ
        <span class="cov0" title="0">buffer := make([]byte, len(testData))
        _, err = conn.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read data: %v", err)
        }</span>

        <span class="cov0" title="0">latency := time.Since(start)
        mt.metrics.AverageLatency = latency

        mt.logger.Info("Data transfer completed",
                zap.String("protocol", protocol),
                zap.String("target", target),
                zap.Duration("latency", latency))

        return nil</span>
}

// GetMetrics возвращает метрики тестирования
func (mt *MASQUETester) GetMetrics() *MASQUEMetrics <span class="cov0" title="0">{
        mt.mu.RLock()
        defer mt.mu.RUnlock()
        return mt.metrics
}</span>

// GetStats возвращает статистику тестирования
func (mt *MASQUETester) GetStats() *MASQUEStats <span class="cov0" title="0">{
        mt.mu.RLock()
        defer mt.mu.RUnlock()
        return mt.stats
}</span>

// IsActive возвращает статус активности тестера
func (mt *MASQUETester) IsActive() bool <span class="cov0" title="0">{
        mt.mu.RLock()
        defer mt.mu.RUnlock()
        return mt.isActive
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package quic

import (
        "context"
        "crypto/tls"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/quic-go/quic-go"
        "go.uber.org/zap"
)

// QUICClient представляет QUIC клиент
type QUICClient struct {
        logger      *zap.Logger
        serverAddr  string
        conn        *quic.Connection
        ctx         context.Context
        cancel      context.CancelFunc
        mu          sync.RWMutex
        isConnected bool
        streams     map[quic.StreamID]quic.Stream
}

// QUICClientConfig конфигурация QUIC клиента
type QUICClientConfig struct {
        ServerAddr     string        `json:"server_addr"`
        MaxStreams     int           `json:"max_streams"`
        ConnectTimeout time.Duration `json:"connect_timeout"`
        IdleTimeout    time.Duration `json:"idle_timeout"`
}

// NewQUICClient создает новый QUIC клиент
func NewQUICClient(logger *zap.Logger, config *QUICClientConfig) *QUICClient <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;QUICClient{
                logger:     logger,
                serverAddr: config.ServerAddr,
                ctx:        ctx,
                cancel:     cancel,
                streams:    make(map[quic.StreamID]quic.Stream),
        }
}</span>

// Connect подключается к QUIC серверу
func (qc *QUICClient) Connect() error <span class="cov0" title="0">{
        qc.mu.Lock()
        defer qc.mu.Unlock()

        if qc.isConnected </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is already connected")
        }</span>

        // Создаем QUIC конфигурацию
        <span class="cov0" title="0">quicConfig := &amp;quic.Config{
                MaxIdleTimeout:  30 * time.Second,
                KeepAlivePeriod: 10 * time.Second,
        }

        // Подключаемся к серверу
        conn, err := quic.DialAddr(qc.ctx, qc.serverAddr, &amp;tls.Config{
                InsecureSkipVerify: true,
                NextProtos:         []string{"quic-test"},
        }, quicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to %s: %v", qc.serverAddr, err)
        }</span>

        <span class="cov0" title="0">qc.conn = &amp;conn
        qc.isConnected = true

        qc.logger.Info("QUIC client connected", zap.String("server", qc.serverAddr))

        // Запускаем обработку потоков
        go qc.handleStreams()

        return nil</span>
}

// Disconnect отключается от сервера
func (qc *QUICClient) Disconnect() error <span class="cov0" title="0">{
        qc.mu.Lock()
        defer qc.mu.Unlock()

        if !qc.isConnected </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">qc.cancel()

        if qc.conn != nil </span><span class="cov0" title="0">{
                (*qc.conn).CloseWithError(0, "client disconnect")
        }</span>

        // Закрываем все потоки
        <span class="cov0" title="0">for _, stream := range qc.streams </span><span class="cov0" title="0">{
                stream.Close()
        }</span>

        <span class="cov0" title="0">qc.isConnected = false
        qc.logger.Info("QUIC client disconnected")

        return nil</span>
}

// IsConnected возвращает статус подключения
func (qc *QUICClient) IsConnected() bool <span class="cov0" title="0">{
        qc.mu.RLock()
        defer qc.mu.RUnlock()
        return qc.isConnected
}</span>

// GetStreams возвращает количество активных потоков
func (qc *QUICClient) GetStreams() int <span class="cov0" title="0">{
        qc.mu.RLock()
        defer qc.mu.RUnlock()
        return len(qc.streams)
}</span>

// SendData отправляет данные на сервер
func (qc *QUICClient) SendData(data []byte) error <span class="cov0" title="0">{
        qc.mu.RLock()
        defer qc.mu.RUnlock()

        if !qc.isConnected || qc.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client is not connected")
        }</span>

        // Создаем новый поток
        <span class="cov0" title="0">stream, err := (*qc.conn).OpenStreamSync(qc.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open stream: %v", err)
        }</span>

        // Добавляем поток в список
        <span class="cov0" title="0">qc.mu.Lock()
        qc.streams[stream.StreamID()] = stream
        qc.mu.Unlock()

        // Отправляем данные
        _, err = stream.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                qc.mu.Lock()
                delete(qc.streams, stream.StreamID())
                qc.mu.Unlock()
                stream.Close()
                return fmt.Errorf("failed to send data: %v", err)
        }</span>

        <span class="cov0" title="0">qc.logger.Debug("Data sent to server",
                zap.Int("bytes", len(data)),
                zap.Uint64("stream_id", uint64(stream.StreamID())))

        return nil</span>
}

// SendTestData отправляет тестовые данные
func (qc *QUICClient) SendTestData(packetSize int, count int) error <span class="cov0" title="0">{
        if !qc.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("client is not connected")
        }</span>

        <span class="cov0" title="0">qc.logger.Info("Sending test data",
                zap.Int("packet_size", packetSize),
                zap.Int("count", count))

        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                // Генерируем тестовые данные
                data := make([]byte, packetSize)
                for j := range data </span><span class="cov0" title="0">{
                        data[j] = byte(i + j)
                }</span>

                <span class="cov0" title="0">if err := qc.SendData(data); err != nil </span><span class="cov0" title="0">{
                        qc.logger.Error("Failed to send test data",
                                zap.Int("packet", i),
                                zap.Error(err))
                        return err
                }</span>

                // Небольшая задержка между пакетами
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">qc.logger.Info("Test data sent successfully", zap.Int("packets", count))
        return nil</span>
}

// handleStreams обрабатывает входящие потоки
func (qc *QUICClient) handleStreams() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        if qc.conn == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">stream, err := (*qc.conn).AcceptStream(qc.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if qc.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">qc.logger.Debug("Failed to accept stream", zap.Error(err))
                                continue</span>
                        }

                        // Добавляем поток в список
                        <span class="cov0" title="0">qc.mu.Lock()
                        qc.streams[stream.StreamID()] = stream
                        qc.mu.Unlock()

                        // Обрабатываем поток
                        go qc.handleStream(stream)</span>
                }
        }
}

// handleStream обрабатывает отдельный поток
func (qc *QUICClient) handleStream(stream quic.Stream) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Удаляем поток из списка
                qc.mu.Lock()
                delete(qc.streams, stream.StreamID())
                qc.mu.Unlock()

                stream.Close()
                qc.logger.Debug("Stream closed", zap.Uint64("stream_id", uint64(stream.StreamID())))
        }</span>()

        <span class="cov0" title="0">buffer := make([]byte, 4096)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        n, err := stream.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        qc.logger.Debug("Stream EOF", zap.Uint64("stream_id", uint64(stream.StreamID())))
                                        return
                                }</span>
                                <span class="cov0" title="0">qc.logger.Debug("Stream read error", zap.Error(err))
                                return</span>
                        }

                        <span class="cov0" title="0">qc.logger.Debug("Received data from server",
                                zap.Uint64("stream_id", uint64(stream.StreamID())),
                                zap.Int("bytes", n))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package quic

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"
)

// QUICManager управляет QUIC сервером и клиентом
type QUICManager struct {
        logger *zap.Logger
        server *QUICServer
        client *QUICClient
        mu     sync.RWMutex
}

// QUICManagerConfig конфигурация менеджера
type QUICManagerConfig struct {
        ServerAddr     string        `json:"server_addr"`
        MaxConnections int           `json:"max_connections"`
        MaxStreams     int           `json:"max_streams"`
        ConnectTimeout time.Duration `json:"connect_timeout"`
        IdleTimeout    time.Duration `json:"idle_timeout"`
}

// NewQUICManager создает новый QUIC менеджер
func NewQUICManager(logger *zap.Logger, config *QUICManagerConfig) *QUICManager <span class="cov0" title="0">{
        // Конфигурация сервера
        serverConfig := &amp;QUICServerConfig{
                Addr:           config.ServerAddr,
                MaxConnections: config.MaxConnections,
                IdleTimeout:    config.IdleTimeout,
                KeepAlive:      10 * time.Second,
        }

        // Конфигурация клиента
        clientConfig := &amp;QUICClientConfig{
                ServerAddr:     "localhost" + config.ServerAddr,
                MaxStreams:     config.MaxStreams,
                ConnectTimeout: config.ConnectTimeout,
                IdleTimeout:    config.IdleTimeout,
        }

        return &amp;QUICManager{
                logger: logger,
                server: NewQUICServer(logger, serverConfig),
                client: NewQUICClient(logger, clientConfig),
        }
}</span>

// StartServer запускает QUIC сервер
func (qm *QUICManager) StartServer() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is already running")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Starting QUIC server")
        return qm.server.Start()</span>
}

// StopServer останавливает QUIC сервер
func (qm *QUICManager) StopServer() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if !qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is not running")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Stopping QUIC server")
        return qm.server.Stop()</span>
}

// StartClient запускает QUIC клиент
func (qm *QUICManager) StartClient() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is already connected")
        }</span>

        <span class="cov0" title="0">if !qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is not running")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Starting QUIC client")
        return qm.client.Connect()</span>
}

// StopClient останавливает QUIC клиент
func (qm *QUICManager) StopClient() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if !qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is not connected")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Stopping QUIC client")
        return qm.client.Disconnect()</span>
}

// SendTestData отправляет тестовые данные
func (qm *QUICManager) SendTestData(packetSize int, count int) error <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()

        if !qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is not connected")
        }</span>

        <span class="cov0" title="0">return qm.client.SendTestData(packetSize, count)</span>
}

// GetStatus возвращает статус сервера и клиента
func (qm *QUICManager) GetStatus() map[string]interface{} <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()

        return map[string]interface{}{
                "server": map[string]interface{}{
                        "running":     qm.server.IsRunning(),
                        "connections": qm.server.GetConnections(),
                },
                "client": map[string]interface{}{
                        "connected": qm.client.IsConnected(),
                        "streams":   qm.client.GetStreams(),
                },
        }
}</span>

// RunTest выполняет тест QUIC соединения
func (qm *QUICManager) RunTest(ctx context.Context, testConfig *TestConfig) error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if !qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is not running")
        }</span>

        <span class="cov0" title="0">if !qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is not connected")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Running QUIC test",
                zap.Int("packet_size", testConfig.PacketSize),
                zap.Int("packet_count", testConfig.PacketCount),
                zap.Duration("duration", testConfig.Duration))

        // Запускаем тест в отдельной горутине
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(time.Second)
                defer ticker.Stop()

                startTime := time.Now()
                packetsSent := 0

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if time.Since(startTime) &gt;= testConfig.Duration </span><span class="cov0" title="0">{
                                        qm.logger.Info("QUIC test completed",
                                                zap.Int("packets_sent", packetsSent),
                                                zap.Duration("duration", time.Since(startTime)))
                                        return
                                }</span>

                                // Отправляем пакеты
                                <span class="cov0" title="0">if err := qm.client.SendTestData(testConfig.PacketSize, testConfig.PacketCount); err != nil </span><span class="cov0" title="0">{
                                        qm.logger.Error("Failed to send test data", zap.Error(err))
                                        return
                                }</span>

                                <span class="cov0" title="0">packetsSent += testConfig.PacketCount</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// TestConfig конфигурация теста
type TestConfig struct {
        PacketSize  int           `json:"packet_size"`
        PacketCount int           `json:"packet_count"`
        Duration    time.Duration `json:"duration"`
}

// GetServer возвращает сервер
func (qm *QUICManager) GetServer() *QUICServer <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()
        return qm.server
}</span>

// GetClient возвращает клиент
func (qm *QUICManager) GetClient() *QUICClient <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()
        return qm.client
}</span>

</pre>
		
		<pre class="file" id="file17" style="display: none">package quic

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "sync"
        "time"

        "github.com/quic-go/quic-go"
        "go.uber.org/zap"
)

// QUICServer представляет QUIC сервер
type QUICServer struct {
        logger      *zap.Logger
        addr        string
        listener    *quic.Listener
        ctx         context.Context
        cancel      context.CancelFunc
        mu          sync.RWMutex
        isRunning   bool
        connections map[string]*quic.Connection
}

// QUICServerConfig конфигурация QUIC сервера
type QUICServerConfig struct {
        Addr           string        `json:"addr"`
        MaxConnections int           `json:"max_connections"`
        IdleTimeout    time.Duration `json:"idle_timeout"`
        KeepAlive      time.Duration `json:"keep_alive"`
}

// NewQUICServer создает новый QUIC сервер
func NewQUICServer(logger *zap.Logger, config *QUICServerConfig) *QUICServer <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;QUICServer{
                logger:      logger,
                addr:        config.Addr,
                ctx:         ctx,
                cancel:      cancel,
                connections: make(map[string]*quic.Connection),
        }
}</span>

// Start запускает QUIC сервер
func (qs *QUICServer) Start() error <span class="cov0" title="0">{
        qs.mu.Lock()
        defer qs.mu.Unlock()

        if qs.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is already running")
        }</span>

        // Создаем простую TLS конфигурацию для разработки
        <span class="cov0" title="0">cert, err := qs.generateSelfSignedCert()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate certificate: %v", err)
        }</span>

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                Certificates:       []tls.Certificate{cert},
                NextProtos:         []string{"quic-test"},
                InsecureSkipVerify: true,
        }

        // Создаем QUIC конфигурацию
        quicConfig := &amp;quic.Config{
                MaxIdleTimeout:  30 * time.Second,
                KeepAlivePeriod: 10 * time.Second,
        }

        // Создаем listener
        listener, err := quic.ListenAddr(qs.addr, tlsConfig, quicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %v", qs.addr, err)
        }</span>

        <span class="cov0" title="0">qs.listener = listener
        qs.isRunning = true

        qs.logger.Info("QUIC server started", zap.String("addr", qs.addr))

        // Запускаем обработку соединений
        go qs.handleConnections()

        return nil</span>
}

// Stop останавливает QUIC сервер
func (qs *QUICServer) Stop() error <span class="cov0" title="0">{
        qs.mu.Lock()
        defer qs.mu.Unlock()

        if !qs.isRunning </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">qs.cancel()

        if qs.listener != nil </span><span class="cov0" title="0">{
                qs.listener.Close()
        }</span>

        // Закрываем все соединения
        <span class="cov0" title="0">for _, conn := range qs.connections </span><span class="cov0" title="0">{
                (*conn).CloseWithError(0, "server shutdown")
        }</span>

        <span class="cov0" title="0">qs.isRunning = false
        qs.logger.Info("QUIC server stopped")

        return nil</span>
}

// IsRunning возвращает статус сервера
func (qs *QUICServer) IsRunning() bool <span class="cov0" title="0">{
        qs.mu.RLock()
        defer qs.mu.RUnlock()
        return qs.isRunning
}</span>

// GetConnections возвращает количество активных соединений
func (qs *QUICServer) GetConnections() int <span class="cov0" title="0">{
        qs.mu.RLock()
        defer qs.mu.RUnlock()
        return len(qs.connections)
}</span>

// handleConnections обрабатывает входящие соединения
func (qs *QUICServer) handleConnections() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qs.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        conn, err := qs.listener.Accept(qs.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if qs.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">qs.logger.Error("Failed to accept connection", zap.Error(err))
                                continue</span>
                        }

                        // Добавляем соединение в список
                        <span class="cov0" title="0">qs.mu.Lock()
                        connID := fmt.Sprintf("%p", conn)
                        qs.connections[connID] = &amp;conn
                        qs.mu.Unlock()

                        qs.logger.Info("New QUIC connection accepted",
                                zap.String("conn_id", connID),
                                zap.String("remote_addr", conn.RemoteAddr().String()))

                        // Обрабатываем соединение
                        go qs.handleConnection(&amp;conn, connID)</span>
                }
        }
}

// handleConnection обрабатывает отдельное соединение
func (qs *QUICServer) handleConnection(conn *quic.Connection, connID string) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Удаляем соединение из списка
                qs.mu.Lock()
                delete(qs.connections, connID)
                qs.mu.Unlock()

                (*conn).CloseWithError(0, "connection closed")
                qs.logger.Info("QUIC connection closed", zap.String("conn_id", connID))
        }</span>()

        // Обрабатываем потоки
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qs.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        stream, err := (*conn).AcceptStream(qs.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if qs.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">qs.logger.Debug("Failed to accept stream", zap.Error(err))
                                continue</span>
                        }

                        // Обрабатываем поток
                        <span class="cov0" title="0">go qs.handleStream(stream, connID)</span>
                }
        }
}

// handleStream обрабатывает поток данных
func (qs *QUICServer) handleStream(stream quic.Stream, connID string) <span class="cov0" title="0">{
        defer stream.Close()

        buffer := make([]byte, 4096)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qs.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        n, err := stream.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                qs.logger.Debug("Stream read error", zap.Error(err))
                                return
                        }</span>

                        <span class="cov0" title="0">qs.logger.Debug("Received data",
                                zap.String("conn_id", connID),
                                zap.Int("bytes", n))

                        // Эхо-ответ
                        _, err = stream.Write(buffer[:n])
                        if err != nil </span><span class="cov0" title="0">{
                                qs.logger.Debug("Stream write error", zap.Error(err))
                                return
                        }</span>
                }
        }
}

// generateTLSConfig создает TLS конфигурацию для разработки
func (qs *QUICServer) generateTLSConfig() (*tls.Config, error) <span class="cov0" title="0">{
        // Создаем самоподписанный сертификат
        cert, err := qs.generateSelfSignedCert()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;tls.Config{
                Certificates:       []tls.Certificate{cert},
                NextProtos:         []string{"quic-test"},
                InsecureSkipVerify: true,
        }, nil</span>
}

// generateSelfSignedCert создает самоподписанный сертификат
func (qs *QUICServer) generateSelfSignedCert() (tls.Certificate, error) <span class="cov0" title="0">{
        // Создаем приватный ключ
        priv, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        // Создаем сертификат
        <span class="cov0" title="0">template := x509.Certificate{
                SerialNumber: big.NewInt(1),
                Subject: pkix.Name{
                        Organization:  []string{"QUCK Test"},
                        Country:       []string{"US"},
                        Province:      []string{""},
                        Locality:      []string{"San Francisco"},
                        StreetAddress: []string{""},
                        PostalCode:    []string{""},
                },
                NotBefore:   time.Now(),
                NotAfter:    time.Now().Add(365 * 24 * time.Hour),
                KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                IPAddresses: []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},
        }

        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;priv.PublicKey, priv)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        // Кодируем в PEM
        <span class="cov0" title="0">certPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})
        keyPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)})

        // Создаем TLS сертификат
        return tls.X509KeyPair(certPEM, keyPEM)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package internal

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strings"
)

// SaveReport сохраняет отчёт по завершении теста в выбранном формате
func SaveReport(cfg TestConfig, metrics any) error <span class="cov0" title="0">{
        format := strings.ToLower(cfg.ReportFormat)
        if format == "" </span><span class="cov0" title="0">{
                format = "md"
        }</span>
        <span class="cov0" title="0">filename := cfg.ReportPath
        if filename == "" </span><span class="cov0" title="0">{
                filename = fmt.Sprintf("report.%s", format)
        }</span>

        <span class="cov0" title="0">var data []byte
        var err error

        switch format </span>{
        case "json":<span class="cov0" title="0">
                data, err = json.MarshalIndent(makeReportJSON(cfg, metrics), "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return saveCSV(filename, makeReportCSV(cfg, metrics))</span>
        case "md":<span class="cov0" title="0">
                data = []byte(makeReportMarkdown(cfg, metrics))</span>
        default:<span class="cov0" title="0">
                data = []byte(makeReportMarkdown(cfg, metrics))</span>
        }

        <span class="cov0" title="0">if format != "csv" </span><span class="cov0" title="0">{
                err = os.WriteFile(filename, data, 0644)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка сохранения отчёта: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("\nОтчёт сохранён:", filename)
        return nil</span>
}

// --- Заглушки для сериализации ---

func makeReportJSON(cfg TestConfig, metrics any) any <span class="cov0" title="0">{
        return map[string]any{
                "params": cfg,
                "metrics": metrics,
        }
}</span>

func makeReportCSV(cfg TestConfig, metrics any) [][]string <span class="cov0" title="0">{
        // TODO: реализовать сериализацию в CSV
        return [][]string{{"param", "value"}, {"mode", cfg.Mode}}
}</span>

func saveCSV(filename string, rows [][]string) error <span class="cov0" title="0">{
        f, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        w := csv.NewWriter(f)
        defer w.Flush()
        return w.WriteAll(rows)</span>
}

func makeReportMarkdown(cfg TestConfig, metrics any) string <span class="cov0" title="0">{
        m, ok := metrics.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("# 2GC CloudBridge QUICK testing\n\n**Параметры:** \"%+v\"\n\n**Метрики:** \"%+v\"\n", cfg, metrics)
        }</span>
        <span class="cov0" title="0">latencies, _ := m["Latencies"].([]float64)
        p50, p95, p99 := calcPercentiles(latencies)
        jitter := calcJitter(latencies)
        avg := avgLatency(latencies)

        tsLatency, _ := m["TimeSeriesLatency"].([]interface{})
        tsThroughput, _ := m["TimeSeriesThroughput"].([]interface{})
        tsPacketLoss, _ := m["TimeSeriesPacketLoss"].([]interface{})
        tsRetransmits, _ := m["TimeSeriesRetransmits"].([]interface{})
        tsHandshakeTime, _ := m["TimeSeriesHandshakeTime"].([]interface{})

        var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf(`# 2GC CloudBridge QUICK testing\n\n**Параметры:** "%+v"\n\n**Метрики:**\n\n- Success: %v\n- Errors: %v\n- BytesSent: %v\n- Avg Latency: %.2f ms\n- p50: %.2f ms\n- p95: %.2f ms\n- p99: %.2f ms\n- Jitter: %.2f ms\n- PacketLoss: %v %%\n- Retransmits: %v\n- TLSVersion: %v\n- CipherSuite: %v\n- SessionResumptionCount: %v\n- 0-RTT: %v\n- 1-RTT: %v\n- OutOfOrder: %v\n- FlowControlEvents: %v\n- KeyUpdateEvents: %v\n- ErrorTypeCounts: %v\n`, cfg, m["Success"], m["Errors"], m["BytesSent"], avg, p50, p95, p99, jitter, m["PacketLoss"], m["Retransmits"], m["TLSVersion"], m["CipherSuite"], m["SessionResumptionCount"], m["ZeroRTTCount"], m["OneRTTCount"], m["OutOfOrderCount"], m["FlowControlEvents"], m["KeyUpdateEvents"], m["ErrorTypeCounts"]))

        buf.WriteString("\n## Временные ряды (Time Series)\n")
        buf.WriteString("\n### Latency (ms)\n")
        buf.WriteString("| Time (s) | Latency (ms) |\n|---|---|\n")
        for _, v := range tsLatency </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Throughput (KB/s)\n| Time (s) | Throughput (KB/s) |\n|---|---|\n")
        for _, v := range tsThroughput </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Packet Loss (%)\n| Time (s) | Packet Loss (%) |\n|---|---|\n")
        for _, v := range tsPacketLoss </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Retransmits\n| Time (s) | Retransmits |\n|---|---|\n")
        for _, v := range tsRetransmits </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.0f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Handshake Time (ms)\n| Time (s) | Handshake Time (ms) |\n|---|---|\n")
        for _, v := range tsHandshakeTime </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        // ASCII-графики
        <span class="cov0" title="0">buf.WriteString("\n#### Latency Graph (ASCII)\n\n```")
        var latencyVals []float64
        for _, v := range tsLatency </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        latencyVals = append(latencyVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(latencyVals, "Latency ms") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Throughput Graph (ASCII)\n\n```")
        var throughputVals []float64
        for _, v := range tsThroughput </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        throughputVals = append(throughputVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(throughputVals, "Throughput KB/s") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Packet Loss Graph (ASCII)\n\n```")
        var lossVals []float64
        for _, v := range tsPacketLoss </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        lossVals = append(lossVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(lossVals, "Packet Loss %") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Retransmits Graph (ASCII)\n\n```")
        var retransVals []float64
        for _, v := range tsRetransmits </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        retransVals = append(retransVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(retransVals, "Retransmits") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Handshake Time Graph (ASCII)\n\n```")
        var hsVals []float64
        for _, v := range tsHandshakeTime </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        hsVals = append(hsVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(hsVals, "Handshake Time ms") + "\n")
        buf.WriteString("```")
        return buf.String()</span>
}

// ascii-график (заглушка, если нет asciigraph)
func asciigraphPlot(data []float64, caption string) string <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        // Можно подключить asciigraph, если доступен, иначе простая заглушка
        <span class="cov0" title="0">max := data[0]
        min := data[0]
        for _, v := range data </span><span class="cov0" title="0">{
                if v &gt; max </span><span class="cov0" title="0">{
                        max = v
                }</span>
                <span class="cov0" title="0">if v &lt; min </span><span class="cov0" title="0">{
                        min = v
                }</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s: min=%.2f max=%.2f (graph suppressed)\n", caption, min, max)</span>
}

// calcPercentiles и calcJitter (дублируем для отчёта)
func calcPercentiles(latencies []float64) (p50, p95, p99 float64) <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0, 0, 0
        }</span>
        <span class="cov0" title="0">copyLat := make([]float64, len(latencies))
        copy(copyLat, latencies)
        sort.Float64s(copyLat)
        idx := func(p float64) int </span><span class="cov0" title="0">{
                return int(p*float64(len(copyLat)-1) + 0.5)
        }</span>
        <span class="cov0" title="0">p50 = copyLat[idx(0.50)]
        p95 = copyLat[idx(0.95)]
        p99 = copyLat[idx(0.99)]
        return</span>
}
func calcJitter(latencies []float64) float64 <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">mean := 0.0
        for _, l := range latencies </span><span class="cov0" title="0">{
                mean += l
        }</span>
        <span class="cov0" title="0">mean /= float64(len(latencies))
        var sum float64
        for _, l := range latencies </span><span class="cov0" title="0">{
                d := l - mean
                sum += d * d
        }</span>
        <span class="cov0" title="0">return (sum / float64(len(latencies)))</span>
}
func avgLatency(latencies []float64) float64 <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">sum := 0.0
        for _, l := range latencies </span><span class="cov0" title="0">{
                sum += l
        }</span>
        <span class="cov0" title="0">return sum / float64(len(latencies))</span>
} </pre>
		
		<pre class="file" id="file19" style="display: none">package internal

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "math/big"
        "time"
)

// GenerateSelfSignedTLS генерирует self-signed сертификат и ключ для TLS
func GenerateSelfSignedTLS() (certPEM, keyPEM []byte) <span class="cov0" title="0">{
        priv, _ := rsa.GenerateKey(rand.Reader, 2048)
        serial := big.NewInt(time.Now().UnixNano())
        certTmpl := x509.Certificate{
                SerialNumber: serial,
                Subject: pkix.Name{Organization: []string{"quck-test"}},
                NotBefore: time.Now(),
                NotAfter:  time.Now().Add(24 * time.Hour),
                KeyUsage:  x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
                BasicConstraintsValid: true,
        }
        certDER, _ := x509.CreateCertificate(rand.Reader, &amp;certTmpl, &amp;certTmpl, &amp;priv.PublicKey, priv)
        certPEM = pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})
        keyPEM = pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)})
        return certPEM, keyPEM
}</span> </pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "quic-test/client"
        "quic-test/internal"
        "quic-test/server"
)

func main() <span class="cov0" title="0">{
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge QUICK testing\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("Тестирование производительности и стабильности QUIC-протокола для CloudBridge 2GC")
        mode := flag.String("mode", "test", "Режим: server | client | test")
        addr := flag.String("addr", ":9000", "Адрес для подключения или прослушивания")
        streams := flag.Int("streams", 1, "Количество потоков на соединение")
        connections := flag.Int("connections", 1, "Количество QUIC-соединений")
        duration := flag.Duration("duration", 0, "Длительность теста (0 — до ручного завершения)")
        packetSize := flag.Int("packet-size", 1200, "Размер пакета (байт)")
        rate := flag.Int("rate", 100, "Частота отправки пакетов (в секунду)")
        reportPath := flag.String("report", "", "Путь к файлу для отчета (опционально)")
        reportFormat := flag.String("report-format", "md", "Формат отчета: csv | md | json")
        certPath := flag.String("cert", "", "Путь к TLS-сертификату (опционально)")
        keyPath := flag.String("key", "", "Путь к TLS-ключу (опционально)")
        pattern := flag.String("pattern", "random", "Шаблон данных: random | zeroes | increment")
        noTLS := flag.Bool("no-tls", false, "Отключить TLS (для тестов)")
        prometheus := flag.Bool("prometheus", false, "Экспортировать метрики Prometheus на /metrics")
        emulateLoss := flag.Float64("emulate-loss", 0, "Вероятность потери пакета (0..1)")
        emulateLatency := flag.Duration("emulate-latency", 0, "Дополнительная задержка перед отправкой пакета (например, 20ms)")
        emulateDup := flag.Float64("emulate-dup", 0, "Вероятность дублирования пакета (0..1)")
        flag.Parse()

        cfg := internal.TestConfig{
                Mode:           *mode,
                Addr:           *addr,
                Streams:        *streams,
                Connections:    *connections,
                Duration:       *duration,
                PacketSize:     *packetSize,
                Rate:           *rate,
                ReportPath:     *reportPath,
                ReportFormat:   *reportFormat,
                CertPath:       *certPath,
                KeyPath:        *keyPath,
                Pattern:        *pattern,
                NoTLS:          *noTLS,
                Prometheus:     *prometheus,
                EmulateLoss:    *emulateLoss,
                EmulateLatency: *emulateLatency,
                EmulateDup:     *emulateDup,
        }

        fmt.Printf("mode=%s, addr=%s, connections=%d, streams=%d, duration=%s, packet-size=%d, rate=%d, report=%s, report-format=%s, cert=%s, key=%s, pattern=%s, no-tls=%v, prometheus=%v\n",
                cfg.Mode, cfg.Addr, cfg.Connections, cfg.Streams, cfg.Duration.String(), cfg.PacketSize, cfg.Rate, cfg.ReportPath, cfg.ReportFormat, cfg.CertPath, cfg.KeyPath, cfg.Pattern, cfg.NoTLS, cfg.Prometheus)

        // Обработка сигналов для graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        _, cancel := context.WithCancel(context.Background())
        defer cancel()

        go func(cancelFunc context.CancelFunc) </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\nПолучен сигнал завершения, завершаем работу...")
                cancelFunc() // Корректное завершение
        }</span>(cancel)

        <span class="cov0" title="0">switch cfg.Mode </span>{
        case "server":<span class="cov0" title="0">
                fmt.Println("Запуск в режиме сервера...")
                server.Run(cfg)</span>
        case "client":<span class="cov0" title="0">
                fmt.Println("Запуск в режиме клиента...")
                client.Run(cfg)</span>
        case "test":<span class="cov0" title="0">
                fmt.Println("Запуск в режиме теста (сервер+клиент)...")</span>
                // TODO: запуск сервера и клиента в одном процессе
        default:<span class="cov0" title="0">
                fmt.Println("Неизвестный режим", cfg.Mode)
                os.Exit(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package server

import (
        "context"
        "crypto/tls"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "quic-test/internal"

        "github.com/fatih/color"
        "github.com/olekukonko/tablewriter"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        quic "github.com/quic-go/quic-go"
)

// serverMetrics хранит метрики сервера
type serverMetrics struct {
        mu          sync.Mutex
        Connections int
        Streams     int
        Bytes       int64
        Errors      int
        Start       time.Time
}

// Run запускает сервер с параметрами из TestConfig
func Run(cfg internal.TestConfig) <span class="cov0" title="0">{
        metrics := &amp;serverMetrics{Start: time.Now()}

        if cfg.Prometheus </span><span class="cov0" title="0">{
                go startPrometheusExporter(metrics)
        }</span>

        <span class="cov0" title="0">tlsConf := makeTLSConfig(cfg)
        listener, err := quic.ListenAddr(cfg.Addr, tlsConf, &amp;quic.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка запуска QUIC сервера: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("QUIC сервер слушает %s", cfg.Addr)

        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                c := make(chan os.Signal, 1)
                signal.Notify(c, os.Interrupt, syscall.SIGTERM)
                &lt;-c
                log.Println("Остановка сервера...")
                listener.Close()
                close(done)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        conn, err := listener.Accept(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                metrics.mu.Lock()
                                metrics.Errors++
                                metrics.mu.Unlock()
                                break</span>
                        }
                        <span class="cov0" title="0">metrics.mu.Lock()
                        metrics.Connections++
                        metrics.mu.Unlock()
                        go handleConn(conn, metrics)</span>
                }
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                        printServerMetrics(metrics)</span>
                }
        }
}

func handleConn(conn quic.Connection, metrics *serverMetrics) <span class="cov0" title="0">{
        defer conn.CloseWithError(0, "bye")
        for </span><span class="cov0" title="0">{
                stream, err := conn.AcceptStream(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.Errors++
                        metrics.mu.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">metrics.mu.Lock()
                metrics.Streams++
                metrics.mu.Unlock()
                go handleStream(stream, metrics)</span>
        }
}

func handleStream(stream quic.Stream, metrics *serverMetrics) <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        for </span><span class="cov0" title="0">{
                n, err := stream.Read(buf)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.Bytes += int64(n)
                        metrics.mu.Unlock()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span><span class="cov0" title="0">{
                                metrics.mu.Lock()
                                metrics.Errors++
                                metrics.mu.Unlock()
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
}

func makeTLSConfig(cfg internal.TestConfig) *tls.Config <span class="cov0" title="0">{
        if cfg.NoTLS </span><span class="cov0" title="0">{
                return &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}
        }</span>
        <span class="cov0" title="0">if cfg.CertPath != "" &amp;&amp; cfg.KeyPath != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(cfg.CertPath, cfg.KeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Ошибка загрузки сертификата: %v", err)
                }</span>
                <span class="cov0" title="0">return &amp;tls.Config{Certificates: []tls.Certificate{cert}, NextProtos: []string{"quic-test"}}</span>
        }
        <span class="cov0" title="0">certPEM, keyPEM := internal.GenerateSelfSignedTLS()
        cert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Ошибка генерации self-signed сертификата: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;tls.Config{Certificates: []tls.Certificate{cert}, NextProtos: []string{"quic-test"}}</span>
}

func printServerMetrics(metrics *serverMetrics) <span class="cov0" title="0">{
        metrics.mu.Lock()
        defer metrics.mu.Unlock()

        fmt.Print("\033[H\033[2J")
        fmt.Println("\033[1;36m  2GC CloudBridge QUICK testing Server\033[0m")

        green := color.New(color.FgGreen).SprintFunc()
        red := color.New(color.FgRed).SprintFunc()
        blue := color.New(color.FgBlue).SprintFunc()
        yellow := color.New(color.FgYellow).SprintFunc()

        table := tablewriter.NewWriter(os.Stdout)
        headers := []string{"Connections", "Streams", "Bytes", "Errors", "Uptime (s)"}
        table.Append(headers)
        uptime := time.Since(metrics.Start).Seconds()
        row := []string{
                green(fmt.Sprintf("%d", metrics.Connections)),
                blue(fmt.Sprintf("%d", metrics.Streams)),
                blue(fmt.Sprintf("%.2f KB", float64(metrics.Bytes)/1024)),
                red(fmt.Sprintf("%d", metrics.Errors)),
                yellow(fmt.Sprintf("%.0f", uptime)),
        }
        table.Append(row)
        table.Render()
}</span>

func startPrometheusExporter(metrics *serverMetrics) <span class="cov0" title="0">{
        connections := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_connections_total",
                Help: "Total connections",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Connections)
        }</span>)
        <span class="cov0" title="0">streams := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_streams_total",
                Help: "Total streams",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Streams)
        }</span>)
        <span class="cov0" title="0">bytes := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_bytes_total",
                Help: "Total bytes received",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Bytes)
        }</span>)
        <span class="cov0" title="0">errors := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_errors_total",
                Help: "Total errors",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Errors)
        }</span>)
        <span class="cov0" title="0">uptime := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_uptime_seconds",
                Help: "Server uptime in seconds",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return time.Since(metrics.Start).Seconds()
        }</span>)

        <span class="cov0" title="0">prometheus.MustRegister(connections, streams, bytes, errors, uptime)
        http.Handle("/metrics", promhttp.Handler())
        fmt.Println("Prometheus endpoint сервера доступен на :2113/metrics")
        http.ListenAndServe(":2113", nil)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
