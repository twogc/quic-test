
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">quic-test/client/client.go (0.0%)</option>
				
				<option value="file1">quic-test/cmd/dashboard/dashboard.go (0.0%)</option>
				
				<option value="file2">quic-test/cmd/enhanced/enhanced.go (0.0%)</option>
				
				<option value="file3">quic-test/cmd/ice/ice.go (0.0%)</option>
				
				<option value="file4">quic-test/cmd/masque/masque.go (0.0%)</option>
				
				<option value="file5">quic-test/cmd/quic-client/main.go (0.0%)</option>
				
				<option value="file6">quic-test/cmd/quic-server/main.go (0.0%)</option>
				
				<option value="file7">quic-test/internal/cli/commands.go (0.0%)</option>
				
				<option value="file8">quic-test/internal/dashboard/metrics.go (0.0%)</option>
				
				<option value="file9">quic-test/internal/ice/ice_tester.go (0.0%)</option>
				
				<option value="file10">quic-test/internal/integration/enhanced_tester.go (0.0%)</option>
				
				<option value="file11">quic-test/internal/masque/capsule_tester.go (0.0%)</option>
				
				<option value="file12">quic-test/internal/masque/connect_ip_tester.go (0.0%)</option>
				
				<option value="file13">quic-test/internal/masque/connect_udp_tester.go (0.0%)</option>
				
				<option value="file14">quic-test/internal/masque/masque_tester.go (0.0%)</option>
				
				<option value="file15">quic-test/internal/quic/client.go (0.0%)</option>
				
				<option value="file16">quic-test/internal/quic/manager.go (0.0%)</option>
				
				<option value="file17">quic-test/internal/quic/server.go (0.0%)</option>
				
				<option value="file18">quic-test/internal/report.go (0.0%)</option>
				
				<option value="file19">quic-test/internal/tlsutil.go (0.0%)</option>
				
				<option value="file20">quic-test/main.go (0.0%)</option>
				
				<option value="file21">quic-test/server/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "context"
        "fmt"
        "math/rand"
        "net/http"
        "os"
        "os/signal"
        "sort"
        "sync"
        "syscall"
        "time"

        "quic-test/internal"
        // "quic-test/internal/report" // —É–¥–∞–ª–∏—Ç—å

        "crypto/tls"
        "errors"
        "sync/atomic"

        "github.com/fatih/color"
        "github.com/guptarohit/asciigraph"
        "github.com/olekukonko/tablewriter"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/quic-go/quic-go"
)

type TimePoint struct {
        Time  float64 // seconds since start
        Value float64
}

// Metrics —Ö—Ä–∞–Ω–∏—Ç –º–µ—Ç—Ä–∏–∫–∏ —Ç–µ—Å—Ç–∞
type Metrics struct {
        mu         sync.Mutex
        Success    int
        Errors     int
        BytesSent  int
        Latencies  []float64
        Timestamps []time.Time
        Throughput []float64
        // Time series for latency and throughput
        TimeSeriesLatency    []TimePoint
        TimeSeriesThroughput []TimePoint

        // --- Advanced QUIC/TLS metrics ---
        PacketLoss             float64 // %
        Retransmits            int
        HandshakeTimes         []float64 // ms
        TLSVersion             string
        CipherSuite            string
        SessionResumptionCount int
        ZeroRTTCount           int
        OneRTTCount            int
        OutOfOrderCount        int
        FlowControlEvents      int
        KeyUpdateEvents        int
        ErrorTypeCounts        map[string]int // error type -&gt; count
        // Time series for new metrics
        TimeSeriesPacketLoss    []TimePoint
        TimeSeriesRetransmits   []TimePoint
        TimeSeriesHandshakeTime []TimePoint
}

// Run –∑–∞–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π —Ç–µ—Å—Ç
func Run(cfg internal.TestConfig) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\n–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, —Ñ–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á—ë—Ç...")
                cancel()
        }</span>()

        <span class="cov0" title="0">metrics := &amp;Metrics{}
        var wg sync.WaitGroup

        if cfg.Prometheus </span><span class="cov0" title="0">{
                go startPrometheusExporter(metrics)
        }</span>
        <span class="cov0" title="0">startTime := time.Now()
        // Time series collector
        go func() </span><span class="cov0" title="0">{
                var lastCount int
                var lastBytes int
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(1 * time.Second):<span class="cov0" title="0">
                                metrics.mu.Lock()
                                now := time.Since(startTime).Seconds()
                                lat := 0.0
                                if len(metrics.Latencies) &gt; lastCount </span><span class="cov0" title="0">{
                                        sum := 0.0
                                        for _, l := range metrics.Latencies[lastCount:] </span><span class="cov0" title="0">{
                                                sum += l
                                        }</span>
                                        <span class="cov0" title="0">lat = sum / float64(len(metrics.Latencies[lastCount:]))</span>
                                }
                                <span class="cov0" title="0">metrics.TimeSeriesLatency = append(metrics.TimeSeriesLatency, TimePoint{Time: now, Value: lat})
                                bytesNow := metrics.BytesSent
                                throughput := float64(bytesNow-lastBytes) / 1024.0
                                metrics.TimeSeriesThroughput = append(metrics.TimeSeriesThroughput, TimePoint{Time: now, Value: throughput})
                                lastCount = len(metrics.Latencies)
                                lastBytes = bytesNow
                                metrics.mu.Unlock()</span>
                        }
                }
        }()

        // --- Ramp-up/ramp-down —Å—Ü–µ–Ω–∞—Ä–∏–π ---
        <span class="cov0" title="0">var rate int64 = int64(cfg.Rate)
        cfgPtr := &amp;cfg // —á—Ç–æ–±—ã –º–µ–Ω—è—Ç—å Rate –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é
        go func() </span><span class="cov0" title="0">{
                minRate := int64(1)
                maxRate := int64(cfg.Rate)
                if maxRate &lt; 10 </span><span class="cov0" title="0">{
                        maxRate = 100 // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ramp-up –¥–æ 100 pps
                }</span>
                <span class="cov0" title="0">step := (maxRate - minRate) / 10
                if step &lt; 1 </span><span class="cov0" title="0">{
                        step = 1
                }</span>
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        // Ramp-up
                        for r := minRate; r &lt;= maxRate; r += step </span><span class="cov0" title="0">{
                                atomic.StoreInt64(&amp;rate, r)
                                time.Sleep(1 * time.Second)
                        }</span>
                        // Ramp-down
                        <span class="cov0" title="0">for r := maxRate; r &gt;= minRate; r -= step </span><span class="cov0" title="0">{
                                atomic.StoreInt64(&amp;rate, r)
                                time.Sleep(1 * time.Second)
                        }</span>
                }
        }()

        <span class="cov0" title="0">for c := 0; c &lt; cfg.Connections; c++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(connID int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        clientConnection(ctx, *cfgPtr, metrics, connID, &amp;rate)
                }</span>(c)
        }

        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫ (–∑–∞–≥–ª—É—à–∫–∞)
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                                printMetrics(metrics, &amp;rate, false)</span>
                        }
                }
        }()

        <span class="cov0" title="0">if cfg.Duration &gt; 0 </span><span class="cov0" title="0">{
                timer := time.NewTimer(cfg.Duration)
                go func() </span><span class="cov0" title="0">{
                        &lt;-timer.C
                        fmt.Println("\n–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω –ø–æ —Ç–∞–π–º–µ—Ä—É, —Ñ–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á—ë—Ç...")
                        cancel()
                }</span>()
        }

        <span class="cov0" title="0">wg.Wait()

        // –§–∏–Ω–∞–ª—å–Ω—ã–π –∫—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥
        printMetrics(metrics, &amp;rate, true)

        err := internal.SaveReport(cfg, metrics)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ç—á—ë—Ç–∞:", err)
        }</span>
}

func clientConnection(ctx context.Context, cfg internal.TestConfig, metrics *Metrics, connID int, ratePtr *int64) <span class="cov0" title="0">{
        var tlsConf *tls.Config
        if cfg.NoTLS </span><span class="cov0" title="0">{
                tlsConf = &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}
        }</span> else<span class="cov0" title="0"> if cfg.CertPath != "" &amp;&amp; cfg.KeyPath != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(cfg.CertPath, cfg.KeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.Errors++
                        if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                                metrics.ErrorTypeCounts = map[string]int{}
                        }</span>
                        <span class="cov0" title="0">metrics.ErrorTypeCounts["tls_load_cert"]++
                        metrics.mu.Unlock()
                        fmt.Println("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞:", err)
                        return</span>
                }
                <span class="cov0" title="0">tlsConf = &amp;tls.Config{Certificates: []tls.Certificate{cert}, InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}</span>
        } else<span class="cov0" title="0"> {
                // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é self-signed cert
                tlsConf = &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}
        }</span>

        <span class="cov0" title="0">handshakeStart := time.Now()
        session, err := quic.DialAddr(ctx, cfg.Addr, tlsConf, nil)
        handshakeTime := time.Since(handshakeStart).Seconds() * 1000 // ms
        metrics.mu.Lock()
        metrics.HandshakeTimes = append(metrics.HandshakeTimes, handshakeTime)
        metrics.TimeSeriesHandshakeTime = append(metrics.TimeSeriesHandshakeTime, TimePoint{Time: time.Since(handshakeStart).Seconds(), Value: handshakeTime})
        if err != nil </span><span class="cov0" title="0">{
                metrics.Errors++
                if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                        metrics.ErrorTypeCounts = map[string]int{}
                }</span>
                <span class="cov0" title="0">metrics.ErrorTypeCounts["quic_handshake"]++
                metrics.mu.Unlock()
                fmt.Println("–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:", err)
                return</span>
        }
        // TLS negotiated params
        <span class="cov0" title="0">state := session.ConnectionState()
        metrics.TLSVersion = tlsVersionString(state.TLS.Version)
        metrics.CipherSuite = cipherSuiteString(state.TLS.CipherSuite)
        if state.TLS.DidResume </span><span class="cov0" title="0">{
                metrics.SessionResumptionCount++
        }</span>
        <span class="cov0" title="0">if state.Used0RTT </span><span class="cov0" title="0">{
                metrics.ZeroRTTCount++
        }</span> else<span class="cov0" title="0"> {
                metrics.OneRTTCount++
        }</span>
        <span class="cov0" title="0">metrics.mu.Unlock()
        defer session.CloseWithError(0, "client done")

        var wg sync.WaitGroup
        for s := 0; s &lt; cfg.Streams; s++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(streamID int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        clientStream(ctx, session, cfg, metrics, connID, streamID, ratePtr)
                }</span>(s)
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

// clientStream —Ä–µ–∞–ª–∏–∑—É–µ—Ç –ø–µ—Ä–µ–¥–∞—á—É –¥–∞–Ω–Ω—ã—Ö –ø–æ QUIC-—Å—Ç—Ä–∏–º—É –∏ —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫
func clientStream(ctx context.Context, session quic.Connection, cfg internal.TestConfig, metrics *Metrics, connID, streamID int, ratePtr *int64) <span class="cov0" title="0">{
        stream, err := session.OpenStreamSync(ctx)
        if err != nil </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                metrics.Errors++
                if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                        metrics.ErrorTypeCounts = map[string]int{}
                }</span>
                <span class="cov0" title="0">metrics.ErrorTypeCounts["open_stream"]++
                metrics.mu.Unlock()
                return</span>
        }
        <span class="cov0" title="0">defer stream.Close()

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è map –¥–ª—è –æ—à–∏–±–æ–∫
        metrics.mu.Lock()
        if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                metrics.ErrorTypeCounts = map[string]int{}
        }</span>
        <span class="cov0" title="0">metrics.mu.Unlock()

        packetSize := cfg.PacketSize
        pattern := cfg.Pattern
        sentPackets := 0
        ackedPackets := 0
        retransmits := 0
        outOfOrder := 0
        var lastSeq int64 = -1
        var seq int64
        start := time.Now()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }
                // –≠–º—É–ª—è—Ü–∏—è –∑–∞–¥–µ—Ä–∂–∫–∏
                <span class="cov0" title="0">if cfg.EmulateLatency &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(cfg.EmulateLatency)
                }</span>
                // –≠–º—É–ª—è—Ü–∏—è –ø–æ—Ç–µ—Ä–∏ –ø–∞–∫–µ—Ç–∞
                <span class="cov0" title="0">if cfg.EmulateLoss &gt; 0 &amp;&amp; rand.Float64() &lt; cfg.EmulateLoss </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.ErrorTypeCounts["emulated_loss"]++
                        metrics.mu.Unlock()
                        continue</span> // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É
                }
                // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–∞–∫–µ—Ç —Å seq
                <span class="cov0" title="0">buf := makePacket(packetSize, pattern)
                seq++
                if len(buf) &gt;= 8 </span><span class="cov0" title="0">{
                        for i := 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                                buf[i] = byte(seq &gt;&gt; (8 * i))
                        }</span>
                }
                // –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞–∫–µ—Ç–∞
                <span class="cov0" title="0">dupCount := 1
                if cfg.EmulateDup &gt; 0 &amp;&amp; rand.Float64() &lt; cfg.EmulateDup </span><span class="cov0" title="0">{
                        dupCount = 2
                        metrics.mu.Lock()
                        metrics.ErrorTypeCounts["emulated_dup"]++
                        metrics.mu.Unlock()
                }</span>
                <span class="cov0" title="0">for d := 0; d &lt; dupCount; d++ </span><span class="cov0" title="0">{
                        startWrite := time.Now()
                        n, err := stream.Write(buf)
                        latency := time.Since(startWrite).Seconds() * 1000
                        metrics.mu.Lock()
                        metrics.BytesSent += n
                        metrics.Success++
                        metrics.Latencies = append(metrics.Latencies, latency)
                        metrics.Timestamps = append(metrics.Timestamps, time.Now())
                        metrics.mu.Unlock()
                        sentPackets++
                        ackedPackets++
                        if err != nil </span><span class="cov0" title="0">{
                                metrics.mu.Lock()
                                metrics.Errors++
                                if metrics.ErrorTypeCounts == nil </span><span class="cov0" title="0">{
                                        metrics.ErrorTypeCounts = map[string]int{}
                                }</span>
                                <span class="cov0" title="0">metrics.ErrorTypeCounts["stream_write"]++
                                retransmits++
                                metrics.Retransmits++
                                var se *quic.StreamError
                                var te *quic.TransportError
                                if errors.As(err, &amp;se) </span><span class="cov0" title="0">{
                                        if uint64(se.ErrorCode) == flowControlErrorCode </span><span class="cov0" title="0">{
                                                metrics.FlowControlEvents++
                                                metrics.ErrorTypeCounts["flow_control"]++
                                        }</span>
                                }
                                <span class="cov0" title="0">if errors.As(err, &amp;te) </span><span class="cov0" title="0">{
                                        if uint64(te.ErrorCode) == keyUpdateErrorCode </span><span class="cov0" title="0">{
                                                metrics.KeyUpdateEvents++
                                                metrics.ErrorTypeCounts["key_update"]++
                                        }</span>
                                }
                                <span class="cov0" title="0">metrics.mu.Unlock()
                                continue</span>
                        }
                        <span class="cov0" title="0">if lastSeq != -1 &amp;&amp; seq != lastSeq+1 </span><span class="cov0" title="0">{
                                outOfOrder++
                                metrics.mu.Lock()
                                metrics.OutOfOrderCount++
                                metrics.mu.Unlock()
                        }</span>
                        <span class="cov0" title="0">lastSeq = seq
                        metrics.mu.Lock()
                        metrics.TimeSeriesRetransmits = append(metrics.TimeSeriesRetransmits, TimePoint{Time: time.Since(start).Seconds(), Value: float64(retransmits)})
                        metrics.TimeSeriesPacketLoss = append(metrics.TimeSeriesPacketLoss, TimePoint{Time: time.Since(start).Seconds(), Value: 100 * float64(sentPackets-ackedPackets) / (float64(sentPackets) + 1e-9)})
                        metrics.mu.Unlock()</span>
                }
                // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –ø–∞–∫–µ—Ç–∞–º–∏
                <span class="cov0" title="0">rate := atomic.LoadInt64(ratePtr)
                if rate &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(time.Second / time.Duration(rate))
                }</span>
        }
}

func makePacket(size int, pattern string) []byte <span class="cov0" title="0">{
        buf := make([]byte, size)
        switch pattern </span>{
        case "zeroes":<span class="cov0" title="0"></span>
                // already zeroed
        case "increment":<span class="cov0" title="0">
                for i := range buf </span><span class="cov0" title="0">{
                        buf[i] = byte(i % 256)
                }</span>
        default:<span class="cov0" title="0">
                _, _ = rand.Read(buf)</span>
        }
        <span class="cov0" title="0">return buf</span>
}

// calcPercentiles –≤—ã—á–∏—Å–ª—è–µ—Ç p50, p95, p99 –¥–ª—è –ª–∞—Ç–µ–Ω—Å–∏
func calcPercentiles(latencies []float64) (p50, p95, p99 float64) <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0, 0, 0
        }</span>
        <span class="cov0" title="0">copyLat := make([]float64, len(latencies))
        copy(copyLat, latencies)
        sort.Float64s(copyLat)
        idx := func(p float64) int </span><span class="cov0" title="0">{
                return int(p*float64(len(copyLat)-1) + 0.5)
        }</span>
        <span class="cov0" title="0">p50 = copyLat[idx(0.50)]
        p95 = copyLat[idx(0.95)]
        p99 = copyLat[idx(0.99)]
        return</span>
}

// calcJitter –≤—ã—á–∏—Å–ª—è–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ª–∞—Ç–µ–Ω—Å–∏
func calcJitter(latencies []float64) float64 <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">mean := 0.0
        for _, l := range latencies </span><span class="cov0" title="0">{
                mean += l
        }</span>
        <span class="cov0" title="0">mean /= float64(len(latencies))
        var sum float64
        for _, l := range latencies </span><span class="cov0" title="0">{
                d := l - mean
                sum += d * d
        }</span>
        <span class="cov0" title="0">return (sum / float64(len(latencies)))</span>
}

func printMetrics(metrics *Metrics, ratePtr *int64, final bool) <span class="cov0" title="0">{
        metrics.mu.Lock()
        defer metrics.mu.Unlock()

        if !final </span><span class="cov0" title="0">{
                fmt.Print("\033[H\033[2J") // –æ—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞ –∏ –∫—É—Ä—Å–æ—Ä –≤ –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
        }</span>
        <span class="cov0" title="0">fmt.Println("\033[1;36m  2GC CloudBridge QUICK testing Client\033[0m")

        green := color.New(color.FgGreen).SprintFunc()
        red := color.New(color.FgRed).SprintFunc()
        blue := color.New(color.FgBlue).SprintFunc()
        yellow := color.New(color.FgYellow).SprintFunc()

        table := tablewriter.NewWriter(os.Stdout)
        headers := []string{"Success", "Errors", "BytesSent", "Avg Latency (ms)", "Throughput", "Uptime (s)", "Rate (pps)"}
        table.Append(headers)

        avgLatency := 0.0
        if len(metrics.Latencies) &gt; 0 </span><span class="cov0" title="0">{
                sum := 0.0
                for _, l := range metrics.Latencies </span><span class="cov0" title="0">{
                        sum += l
                }</span>
                <span class="cov0" title="0">avgLatency = sum / float64(len(metrics.Latencies))</span>
        }

        // Percentiles &amp; jitter
        <span class="cov0" title="0">p50, p95, p99 := calcPercentiles(metrics.Latencies)
        jitter := calcJitter(metrics.Latencies)

        uptime := 0.0
        if len(metrics.Timestamps) &gt; 0 </span><span class="cov0" title="0">{
                uptime = time.Since(metrics.Timestamps[0]).Seconds()
        }</span>

        <span class="cov0" title="0">throughput := 0.0
        if uptime &gt; 0 </span><span class="cov0" title="0">{
                throughput = float64(metrics.BytesSent) / 1024.0 / uptime
        }</span>

        <span class="cov0" title="0">rate := int64(0)
        if ratePtr != nil </span><span class="cov0" title="0">{
                rate = atomic.LoadInt64(ratePtr)
        }</span>

        <span class="cov0" title="0">row := []string{
                green(fmt.Sprintf("%d", metrics.Success)),
                red(fmt.Sprintf("%d", metrics.Errors)),
                blue(fmt.Sprintf("%.2f KB", float64(metrics.BytesSent)/1024)),
                yellow(fmt.Sprintf("%.2f", avgLatency)),
                blue(fmt.Sprintf("%.2f KB/s", throughput)),
                fmt.Sprintf("%.0f", uptime),
                fmt.Sprintf("%d", rate),
        }
        table.Append(row)
        table.Render()

        fmt.Printf("Percentiles: p50=%.2f ms, p95=%.2f ms, p99=%.2f ms\n", p50, p95, p99)
        fmt.Printf("Jitter: %.2f ms\n", jitter)

        if len(metrics.Latencies) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println(yellow(asciigraph.Plot(metrics.Latencies, asciigraph.Height(8), asciigraph.Width(60), asciigraph.Caption("Latency ms"))))
        }</span>
}

func startPrometheusExporter(metrics *Metrics) <span class="cov0" title="0">{
        success := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_success_total",
                Help: "Total successful packets sent",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Success)
        }</span>)
        <span class="cov0" title="0">errors := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_errors_total",
                Help: "Total errors",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Errors)
        }</span>)
        <span class="cov0" title="0">bytesSent := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_bytes_sent",
                Help: "Total bytes sent",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.BytesSent)
        }</span>)
        <span class="cov0" title="0">avgLatency := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_avg_latency_ms",
                Help: "Average latency in ms",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                if len(metrics.Latencies) == 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">sum := 0.0
                for _, l := range metrics.Latencies </span><span class="cov0" title="0">{
                        sum += l
                }</span>
                <span class="cov0" title="0">return sum / float64(len(metrics.Latencies))</span>
        })
        <span class="cov0" title="0">throughput := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_client_throughput_kbps",
                Help: "Current throughput in KB/s",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                uptime := 0.0
                if len(metrics.Timestamps) &gt; 0 </span><span class="cov0" title="0">{
                        uptime = time.Since(metrics.Timestamps[0]).Seconds()
                }</span>
                <span class="cov0" title="0">if uptime &gt; 0 </span><span class="cov0" title="0">{
                        return float64(metrics.BytesSent) / 1024.0 / uptime
                }</span>
                <span class="cov0" title="0">return 0</span>
        })

        <span class="cov0" title="0">prometheus.MustRegister(success, errors, bytesSent, avgLatency, throughput)
        http.Handle("/metrics", promhttp.Handler())
        fmt.Println("Prometheus endpoint –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ :2112/metrics")
        http.ListenAndServe(":2112", nil)</span>
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è TLSVersion/CipherSuite
func tlsVersionString(v uint16) string <span class="cov0" title="0">{
        switch v </span>{
        case tls.VersionTLS13:<span class="cov0" title="0">
                return "TLS 1.3"</span>
        case tls.VersionTLS12:<span class="cov0" title="0">
                return "TLS 1.2"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("0x%x", v)</span>
        }
}
func cipherSuiteString(cs uint16) string <span class="cov0" title="0">{
        switch cs </span>{
        case tls.TLS_AES_128_GCM_SHA256:<span class="cov0" title="0">
                return "TLS_AES_128_GCM_SHA256"</span>
        case tls.TLS_AES_256_GCM_SHA384:<span class="cov0" title="0">
                return "TLS_AES_256_GCM_SHA384"</span>
        case tls.TLS_CHACHA20_POLY1305_SHA256:<span class="cov0" title="0">
                return "TLS_CHACHA20_POLY1305_SHA256"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("0x%x", cs)</span>
        }
}

// –ö–æ–¥—ã –æ—à–∏–±–æ–∫ –∏–∑ RFC 9000/QUIC:
const (
        flowControlErrorCode = 0x3 // FlowControlError
        keyUpdateErrorCode   = 0xE // KeyUpdateError
)
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
)

func main() <span class="cov0" title="0">{
        // –ü–∞—Ä—Å–∏–Ω–≥ —Ñ–ª–∞–≥–æ–≤
        addr := flag.String("addr", ":9990", "–ê–¥—Ä–µ—Å –¥–ª—è –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞")
        flag.Parse()

        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge Dashboard\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\n–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–∞—à–±–æ—Ä–¥–∞...")
                os.Exit(0)
        }</span>()

        <span class="cov0" title="0">startDashboard(*addr)</span>
}

// startDashboard –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
func startDashboard(addr string) <span class="cov0" title="0">{
        fmt.Println("üöÄ Starting QUIC Testing Dashboard on http://localhost:9990")
        fmt.Println("üìä Open your browser and navigate to http://localhost:9990")
        fmt.Println("üõë Press Ctrl+C to stop the server")
        fmt.Println("üîç Advanced analysis features available at:")
        fmt.Println("   - /api/analysis/deep - Deep protocol analysis")
        fmt.Println("   - /api/analysis/protocol - Protocol analysis")
        fmt.Println("   - /api/network/simulation - Network simulation")

        // –ó–∞–ø—É—Å–∫–∞–µ–º HTTP —Å–µ—Ä–≤–µ—Ä
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/" </span><span class="cov0" title="0">{
                        http.ServeFile(w, r, "index.html")
                }</span> else<span class="cov0" title="0"> {
                        http.ServeFile(w, r, r.URL.Path[1:])
                }</span>
        })

        // API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "server": map[string]interface{}{
                                "running": false,
                        },
                        "client": map[string]interface{}{
                                "running": false,
                        },
                })
        }</span>)

        // MASQUE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/masque/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "MASQUE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/masque/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "MASQUE testing stopped",
                })
        }</span>)

        // ICE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/ice/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "ICE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/ice/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "ICE testing stopped",
                })
        }</span>)

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä
        <span class="cov0" title="0">fmt.Printf("üöÄ Dashboard –∑–∞–ø—É—â–µ–Ω –Ω–∞ http://localhost%s\n", addr)
        log.Fatal(http.ListenAndServe(addr, nil))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "strings"
        "time"

        "quic-test/internal/ice"
        "quic-test/internal/integration"
        "quic-test/internal/masque"

        "go.uber.org/zap"
)

// runEnhancedTesting –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runEnhancedTesting(logger *zap.Logger, masqueServer, masqueTargets, iceStunServers, iceTurnServers, iceTurnUser, iceTurnPass string) <span class="cov0" title="0">{
        logger.Info("Starting enhanced testing (MASQUE + ICE + QUIC)")

        // –ü–∞—Ä—Å–∏–º MASQUE —Ü–µ–ª–µ–≤—ã–µ —Ö–æ—Å—Ç—ã
        masqueTargetsList := strings.Split(masqueTargets, ",")
        for i, target := range masqueTargetsList </span><span class="cov0" title="0">{
                masqueTargetsList[i] = strings.TrimSpace(target)
        }</span>

        // –ü–∞—Ä—Å–∏–º STUN —Å–µ—Ä–≤–µ—Ä—ã
        <span class="cov0" title="0">stunList := []string{}
        if iceStunServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(iceStunServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                stunList = append(stunList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // –ü–∞—Ä—Å–∏–º TURN —Å–µ—Ä–≤–µ—Ä—ã
        <span class="cov0" title="0">turnList := []string{}
        if iceTurnServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(iceTurnServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                turnList = append(turnList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        <span class="cov0" title="0">masqueConfig := &amp;masque.MASQUEConfig{
                ServerURL:       masqueServer,
                UDPTargets:      masqueTargetsList,
                IPTargets:       []string{"8.8.8.8", "1.1.1.1"},
                ConnectTimeout:  30 * time.Second,
                TestTimeout:     60 * time.Second,
                ConcurrentTests: 5,
                TestDuration:    30 * time.Second,
        }

        iceConfig := &amp;ice.ICEConfig{
                StunServers:       stunList,
                TurnServers:       turnList,
                TurnUsername:      iceTurnUser,
                TurnPassword:      iceTurnPass,
                GatheringTimeout:  30 * time.Second,
                ConnectionTimeout: 60 * time.Second,
                TestDuration:      30 * time.Second,
                ConcurrentTests:   5,
        }

        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        config := &amp;integration.EnhancedConfig{
                MASQUE:          *masqueConfig,
                ICE:             *iceConfig,
                TestDuration:    60 * time.Second,
                ConcurrentTests: 5,
                EnableMASQUE:    true,
                EnableICE:       true,
        }

        // –°–æ–∑–¥–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ç–µ—Å—Ç–µ—Ä
        tester := integration.NewEnhancedTester(logger, config)

        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Minute)
        defer cancel()

        if err := tester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start enhanced testing", zap.Error(err))
        }</span>

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        <span class="cov0" title="0">&lt;-ctx.Done()

        // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        metrics := tester.GetMetrics()

        logger.Info("Enhanced testing completed",
                zap.Int64("total_tests", metrics.TotalTests),
                zap.Int64("successful_tests", metrics.SuccessfulTests),
                zap.Float64("success_rate", metrics.SuccessRate),
                zap.Duration("test_duration", metrics.TestDuration))

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ—Å—Ç–µ—Ä
        tester.Stop()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "strings"
        "time"

        "quic-test/internal/ice"

        "go.uber.org/zap"
)

// runICETesting –∑–∞–ø—É—Å–∫–∞–µ—Ç ICE/STUN/TURN —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runICETesting(logger *zap.Logger, stunServers, turnServers, turnUser, turnPass string) <span class="cov0" title="0">{
        logger.Info("Starting ICE testing",
                zap.String("stun_servers", stunServers),
                zap.String("turn_servers", turnServers))

        // –ü–∞—Ä—Å–∏–º STUN —Å–µ—Ä–≤–µ—Ä—ã
        stunList := []string{}
        if stunServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(stunServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                stunList = append(stunList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // –ü–∞—Ä—Å–∏–º TURN —Å–µ—Ä–≤–µ—Ä—ã
        <span class="cov0" title="0">turnList := []string{}
        if turnServers != "" </span><span class="cov0" title="0">{
                for _, server := range strings.Split(turnServers, ",") </span><span class="cov0" title="0">{
                        if server != "" </span><span class="cov0" title="0">{
                                turnList = append(turnList, strings.TrimSpace(server))
                        }</span>
                }
        }

        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é ICE
        <span class="cov0" title="0">iceConfig := &amp;ice.ICEConfig{
                StunServers:       stunList,
                TurnServers:       turnList,
                TurnUsername:      turnUser,
                TurnPassword:      turnPass,
                GatheringTimeout:  30 * time.Second,
                ConnectionTimeout: 60 * time.Second,
                TestDuration:      30 * time.Second,
                ConcurrentTests:   5,
        }

        // –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º ICE —Ç–µ—Å—Ç–µ—Ä
        tester := ice.NewICETester(logger, iceConfig)

        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        if err := tester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start ICE testing", zap.Error(err))
        }</span>

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        <span class="cov0" title="0">&lt;-ctx.Done()

        // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        metrics := tester.GetMetrics()

        logger.Info("ICE testing completed",
                zap.Int64("stun_requests", metrics.StunRequests),
                zap.Int64("stun_responses", metrics.StunResponses),
                zap.Int64("turn_allocations", metrics.TurnAllocations),
                zap.Int64("candidates_gathered", metrics.CandidatesGathered),
                zap.Int64("connections_successful", metrics.ConnectionsSuccessful))

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ—Å—Ç–µ—Ä
        tester.Stop()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "strings"
        "time"

        "quic-test/internal/masque"

        "go.uber.org/zap"
)

// runMASQUETesting –∑–∞–ø—É—Å–∫–∞–µ—Ç MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runMASQUETesting(logger *zap.Logger, masqueServer, masqueTargets string) <span class="cov0" title="0">{
        logger.Info("Starting MASQUE testing",
                zap.String("server", masqueServer),
                zap.String("targets", masqueTargets))

        // –ü–∞—Ä—Å–∏–º —Ü–µ–ª–µ–≤—ã–µ —Ö–æ—Å—Ç—ã
        targets := strings.Split(masqueTargets, ",")
        for i, target := range targets </span><span class="cov0" title="0">{
                targets[i] = strings.TrimSpace(target)
        }</span>

        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é MASQUE
        <span class="cov0" title="0">config := &amp;masque.MASQUEConfig{
                ServerURL:       masqueServer,
                UDPTargets:      targets,
                IPTargets:       []string{"8.8.8.8", "1.1.1.1"},
                ConnectTimeout:  30 * time.Second,
                TestTimeout:     60 * time.Second,
                ConcurrentTests: 5,
                TestDuration:    30 * time.Second,
        }

        // –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º MASQUE —Ç–µ—Å—Ç–µ—Ä
        tester := masque.NewMASQUETester(logger, config)

        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        if err := tester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start MASQUE testing", zap.Error(err))
        }</span>

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        <span class="cov0" title="0">&lt;-ctx.Done()

        // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        metrics := tester.GetMetrics()

        logger.Info("MASQUE testing completed",
                zap.Int64("connect_udp_successes", metrics.ConnectUDPSuccesses),
                zap.Int64("connect_ip_successes", metrics.ConnectIPSuccesses),
                zap.Float64("datagram_loss_rate", metrics.DatagramLossRate),
                zap.Float64("throughput_mbps", metrics.Throughput),
                zap.Duration("average_latency", metrics.AverageLatency))

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ—Å—Ç–µ—Ä
        tester.Stop()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "quic-test/client"
        "quic-test/internal"
)

func main() <span class="cov0" title="0">{
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge QUIC Client\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")

        // –ü–∞—Ä—Å–∏–Ω–≥ —Ñ–ª–∞–≥–æ–≤
        addr := flag.String("addr", "127.0.0.1:9000", "–ê–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è")
        streams := flag.Int("streams", 1, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ –Ω–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ")
        connections := flag.Int("connections", 1, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ QUIC-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π")
        duration := flag.Duration("duration", 0, "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∞ (0 ‚Äî –¥–æ —Ä—É—á–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è)")
        packetSize := flag.Int("packet-size", 1200, "–†–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞ (–±–∞–π—Ç)")
        rate := flag.Int("rate", 100, "–ß–∞—Å—Ç–æ—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∞–∫–µ—Ç–æ–≤ (–≤ —Å–µ–∫—É–Ω–¥—É)")
        reportPath := flag.String("report", "", "–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –æ—Ç—á–µ—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        reportFormat := flag.String("report-format", "md", "–§–æ—Ä–º–∞—Ç –æ—Ç—á–µ—Ç–∞: csv | md | json")
        certPath := flag.String("cert", "", "–ü—É—Ç—å –∫ TLS-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        keyPath := flag.String("key", "", "–ü—É—Ç—å –∫ TLS-–∫–ª—é—á—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        pattern := flag.String("pattern", "random", "–®–∞–±–ª–æ–Ω –¥–∞–Ω–Ω—ã—Ö: random | zeroes | increment")
        noTLS := flag.Bool("no-tls", false, "–û—Ç–∫–ª—é—á–∏—Ç—å TLS (–¥–ª—è —Ç–µ—Å—Ç–æ–≤)")
        prometheus := flag.Bool("prometheus", false, "–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ Prometheus –Ω–∞ /metrics")
        emulateLoss := flag.Float64("emulate-loss", 0, "–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ—Ç–µ—Ä–∏ –ø–∞–∫–µ—Ç–∞ (0..1)")
        emulateLatency := flag.Duration("emulate-latency", 0, "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –ø–∞–∫–µ—Ç–∞")
        emulateDup := flag.Float64("emulate-dup", 0, "–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞–∫–µ—Ç–∞ (0..1)")
        pprofAddr := flag.String("pprof-addr", "", "–ê–¥—Ä–µ—Å –¥–ª—è pprof (–Ω–∞–ø—Ä–∏–º–µ—Ä, :6060)")
        slaRttP95 := flag.Duration("sla-rtt-p95", 0, "SLA: –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π RTT p95 (–Ω–∞–ø—Ä–∏–º–µ—Ä, 100ms)")
        slaLoss := flag.Float64("sla-loss", 0, "SLA: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø–æ—Ç–µ—Ä—è –ø–∞–∫–µ—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.01)")
        flag.Parse()

        // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–ª–∞–≥–æ–≤
        if err := validateFlags(*noTLS, *rate, *emulateLoss, *emulateDup, *slaLoss); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg := internal.TestConfig{
                Mode:           "client",
                Addr:           *addr,
                Streams:        *streams,
                Connections:    *connections,
                Duration:       *duration,
                PacketSize:     *packetSize,
                Rate:           *rate,
                ReportPath:     *reportPath,
                ReportFormat:   *reportFormat,
                CertPath:       *certPath,
                KeyPath:        *keyPath,
                Pattern:        *pattern,
                NoTLS:          *noTLS,
                Prometheus:     *prometheus,
                EmulateLoss:    *emulateLoss,
                EmulateLatency: *emulateLatency,
                EmulateDup:     *emulateDup,
                PprofAddr:      *pprofAddr,
                SlaRttP95:      *slaRttP95,
                SlaLoss:        *slaLoss,
        }

        fmt.Printf("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ %s —Å %d —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏, %d –ø–æ—Ç–æ–∫–æ–≤ –Ω–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ\n",
                cfg.Addr, cfg.Connections, cfg.Streams)

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\n–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –∑–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É...")
                cancel()
        }</span>()

        // –ü–µ—Ä–µ–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ client.Run
        <span class="cov0" title="0">_ = ctx // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è graceful shutdown

        // –ó–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞
        client.Run(cfg)</span>
}

// validateFlags –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∞—Ü–∏–π —Ñ–ª–∞–≥–æ–≤
func validateFlags(noTLS bool, rate int, emulateLoss, emulateDup, slaLoss float64) error <span class="cov0" title="0">{
        if rate &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("rate –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º")
        }</span>
        <span class="cov0" title="0">if emulateLoss &lt; 0 || emulateLoss &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("emulate-loss –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [0, 1]")
        }</span>
        <span class="cov0" title="0">if emulateDup &lt; 0 || emulateDup &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("emulate-dup –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [0, 1]")
        }</span>
        <span class="cov0" title="0">if slaLoss &lt; 0 || slaLoss &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("sla-loss –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [0, 1]")
        }</span>
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∑–¥–µ—Å—å
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "quic-test/internal"
        "quic-test/server"
)

func main() <span class="cov0" title="0">{
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge QUIC Server\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")

        // –ü–∞—Ä—Å–∏–Ω–≥ —Ñ–ª–∞–≥–æ–≤
        addr := flag.String("addr", ":9000", "–ê–¥—Ä–µ—Å –¥–ª—è –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è")
        certPath := flag.String("cert", "", "–ü—É—Ç—å –∫ TLS-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        keyPath := flag.String("key", "", "–ü—É—Ç—å –∫ TLS-–∫–ª—é—á—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        noTLS := flag.Bool("no-tls", false, "–û—Ç–∫–ª—é—á–∏—Ç—å TLS (–¥–ª—è —Ç–µ—Å—Ç–æ–≤)")
        prometheus := flag.Bool("prometheus", false, "–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ Prometheus –Ω–∞ /metrics")
        pprofAddr := flag.String("pprof-addr", "", "–ê–¥—Ä–µ—Å –¥–ª—è pprof (–Ω–∞–ø—Ä–∏–º–µ—Ä, :6060)")
        flag.Parse()

        // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–ª–∞–≥–æ–≤
        if err := validateFlags(*noTLS, *certPath, *keyPath); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg := internal.TestConfig{
                Mode:       "server",
                Addr:       *addr,
                CertPath:   *certPath,
                KeyPath:    *keyPath,
                NoTLS:      *noTLS,
                Prometheus: *prometheus,
                PprofAddr:  *pprofAddr,
        }

        fmt.Printf("–ó–∞–ø—É—Å–∫ QUIC —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ %s\n", cfg.Addr)
        if cfg.Prometheus </span><span class="cov0" title="0">{
                fmt.Println("Prometheus –º–µ—Ç—Ä–∏–∫–∏ –±—É–¥—É—Ç –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞ /metrics")
        }</span>
        <span class="cov0" title="0">if cfg.PprofAddr != "" </span><span class="cov0" title="0">{
                fmt.Printf("pprof –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ %s/debug/pprof\n", cfg.PprofAddr)
        }</span>

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è graceful shutdown
        <span class="cov0" title="0">sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\n–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞...")
                os.Exit(0)
        }</span>()

        // –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
        <span class="cov0" title="0">server.Run(cfg)</span>
}

// validateFlags –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–º–±–∏–Ω–∞—Ü–∏–π —Ñ–ª–∞–≥–æ–≤
func validateFlags(noTLS bool, certPath, keyPath string) error <span class="cov0" title="0">{
        if !noTLS &amp;&amp; certPath != "" &amp;&amp; keyPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω cert, –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–∫–∞–∑–∞–Ω key")
        }</span>
        <span class="cov0" title="0">if !noTLS &amp;&amp; certPath == "" &amp;&amp; keyPath != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω key, –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–∫–∞–∑–∞–Ω cert")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "time"

        "quic-test/internal/dashboard"
        "quic-test/internal/quic"

        "go.uber.org/zap"
)

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –º–µ—Ç—Ä–∏–∫
var metricsManager = dashboard.NewMetricsManager()

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π QUIC –º–µ–Ω–µ–¥–∂–µ—Ä
var quicManager *quic.QUICManager

// Command –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –∫–æ–º–∞–Ω–¥—É CLI
type Command struct {
        Name        string
        Description string
        Handler     func(args []string) error
}

// Commands —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
var Commands = map[string]Command{
        "server": {
                Name:        "server",
                Description: "–ó–∞–ø—É—Å–∫ QUIC —Å–µ—Ä–≤–µ—Ä–∞",
                Handler:     runServer,
        },
        "client": {
                Name:        "client",
                Description: "–ó–∞–ø—É—Å–∫ QUIC –∫–ª–∏–µ–Ω—Ç–∞",
                Handler:     runClient,
        },
        "test": {
                Name:        "test",
                Description: "–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–µ—Ä–≤–µ—Ä+–∫–ª–∏–µ–Ω—Ç)",
                Handler:     runTest,
        },
        "dashboard": {
                Name:        "dashboard",
                Description: "–ó–∞–ø—É—Å–∫ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞",
                Handler:     runDashboard,
        },
        "masque": {
                Name:        "masque",
                Description: "–ó–∞–ø—É—Å–∫ MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è",
                Handler:     runMASQUE,
        },
        "ice": {
                Name:        "ice",
                Description: "–ó–∞–ø—É—Å–∫ ICE/STUN/TURN —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è",
                Handler:     runICE,
        },
        "enhanced": {
                Name:        "enhanced",
                Description: "–ó–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (MASQUE + ICE + QUIC)",
                Handler:     runEnhanced,
        },
}

// ParseFlags –ø–∞—Ä—Å–∏—Ç —Ñ–ª–∞–≥–∏ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
func ParseFlags() (string, map[string]interface{}) <span class="cov0" title="0">{
        mode := flag.String("mode", "server", "–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: server, client, test, dashboard, masque, ice, enhanced")

        // –û–±—â–∏–µ —Ñ–ª–∞–≥–∏
        addr := flag.String("addr", "localhost:8443", "–ê–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞")
        cert := flag.String("cert", "server.crt", "–ü—É—Ç—å –∫ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—É")
        key := flag.String("key", "server.key", "–ü—É—Ç—å –∫ –ø—Ä–∏–≤–∞—Ç–Ω–æ–º—É –∫–ª—é—á—É")
        prometheus := flag.Bool("prometheus", false, "–í–∫–ª—é—á–∏—Ç—å Prometheus –º–µ—Ç—Ä–∏–∫–∏")

        // –§–ª–∞–≥–∏ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
        connections := flag.Int("connections", 1, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π")
        streams := flag.Int("streams", 1, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤")
        packetSize := flag.Int("packet-size", 1024, "–†–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞")
        rate := flag.Int("rate", 100, "–°–∫–æ—Ä–æ—Å—Ç—å –æ—Ç–ø—Ä–∞–≤–∫–∏ (–ø–∞–∫–µ—Ç–æ–≤/—Å–µ–∫)")
        pattern := flag.String("pattern", "burst", "–ü–∞—Ç—Ç–µ—Ä–Ω –æ—Ç–ø—Ä–∞–≤–∫–∏: burst, steady, random")

        // –§–ª–∞–≥–∏ –¥–ª—è MASQUE
        masqueServer := flag.String("masque-server", "localhost:8443", "MASQUE —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è")
        masqueTargets := flag.String("masque-targets", "8.8.8.8:53,1.1.1.1:53", "–¶–µ–ª–µ–≤—ã–µ —Ö–æ—Å—Ç—ã –¥–ª—è CONNECT-UDP (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)")

        // –§–ª–∞–≥–∏ –¥–ª—è ICE
        iceStunServers := flag.String("ice-stun", "stun.l.google.com:19302,stun1.l.google.com:19302", "STUN —Å–µ—Ä–≤–µ—Ä—ã (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)")
        iceTurnServers := flag.String("ice-turn", "", "TURN —Å–µ—Ä–≤–µ—Ä—ã (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)")
        iceTurnUser := flag.String("ice-turn-user", "", "TURN username")
        iceTurnPass := flag.String("ice-turn-pass", "", "TURN password")

        flag.Parse()

        config := map[string]interface{}{
                "addr":           *addr,
                "cert":           *cert,
                "key":            *key,
                "prometheus":     *prometheus,
                "connections":    *connections,
                "streams":        *streams,
                "packetSize":     *packetSize,
                "rate":           *rate,
                "pattern":        *pattern,
                "masqueServer":   *masqueServer,
                "masqueTargets":  *masqueTargets,
                "iceStunServers": *iceStunServers,
                "iceTurnServers": *iceTurnServers,
                "iceTurnUser":    *iceTurnUser,
                "iceTurnPass":    *iceTurnPass,
        }

        return *mode, config
}</span>

// CreateLogger —Å–æ–∑–¥–∞–µ—Ç –ª–æ–≥–≥–µ—Ä
func CreateLogger() *zap.Logger <span class="cov0" title="0">{
        logger, err := zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to create logger:", err)
        }</span>
        <span class="cov0" title="0">return logger</span>
}

// ShowHelp –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø—Ä–∞–≤–∫—É
func ShowHelp() <span class="cov0" title="0">{
        fmt.Println("QUIC Testing Tool - –†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ QUIC –ø—Ä–æ—Ç–æ–∫–æ–ª–∞")
        fmt.Println()
        fmt.Println("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:")
        fmt.Println("  quic-test -mode=&lt;—Ä–µ–∂–∏–º&gt; [—Ñ–ª–∞–≥–∏]")
        fmt.Println()
        fmt.Println("–†–µ–∂–∏–º—ã:")
        for name, cmd := range Commands </span><span class="cov0" title="0">{
                fmt.Printf("  %-10s - %s\n", name, cmd.Description)
        }</span>
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("–§–ª–∞–≥–∏:")
        flag.PrintDefaults()</span>
}

// runServer –∑–∞–ø—É—Å–∫–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä
func runServer(args []string) error <span class="cov0" title="0">{
        fmt.Println("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ —Å–µ—Ä–≤–µ—Ä–∞...")
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
        return nil
}</span>

// runClient –∑–∞–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç
func runClient(args []string) error <span class="cov0" title="0">{
        fmt.Println("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ –∫–ª–∏–µ–Ω—Ç–∞...")
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞
        return nil
}</span>

// runTest –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runTest(args []string) error <span class="cov0" title="0">{
        fmt.Println("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ —Ç–µ—Å—Ç–∞ (—Å–µ—Ä–≤–µ—Ä+–∫–ª–∏–µ–Ω—Ç)...")
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        return nil
}</span>

// runDashboard –∑–∞–ø—É—Å–∫–∞–µ—Ç dashboard
func runDashboard(args []string) error <span class="cov0" title="0">{
        fmt.Println("üöÄ Starting QUIC Testing Dashboard on http://localhost:9990")
        fmt.Println("üìä Open your browser and navigate to http://localhost:9990")
        fmt.Println("üõë Press Ctrl+C to stop the server")
        fmt.Println("üîç Advanced analysis features available at:")
        fmt.Println("   - /api/analysis/deep - Deep protocol analysis")
        fmt.Println("   - /api/analysis/protocol - Protocol analysis")
        fmt.Println("   - /api/network/simulation - Network simulation")

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º QUIC –º–µ–Ω–µ–¥–∂–µ—Ä
        logger := CreateLogger()
        quicConfig := &amp;quic.QUICManagerConfig{
                ServerAddr:     ":9001", // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –ø–æ—Ä—Ç –¥–ª—è QUIC
                MaxConnections: 10,
                MaxStreams:     100,
                ConnectTimeout: 30 * time.Second,
                IdleTimeout:    60 * time.Second,
        }
        quicManager = quic.NewQUICManager(logger, quicConfig)

        // –ó–∞–ø—É—Å–∫–∞–µ–º HTTP —Å–µ—Ä–≤–µ—Ä
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/" </span><span class="cov0" title="0">{
                        http.ServeFile(w, r, "index.html")
                }</span> else<span class="cov0" title="0"> {
                        http.ServeFile(w, r, r.URL.Path[1:])
                }</span>
        })

        // API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/status", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        json.NewEncoder(w).Encode(quicManager.GetStatus())
                }</span> else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "server": map[string]interface{}{
                                        "running": false,
                                },
                                "client": map[string]interface{}{
                                        "running": false,
                                },
                        })
                }</span>
        })

        // Metrics endpoint
        <span class="cov0" title="0">http.HandleFunc("/api/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.UpdateMetrics()
                json.NewEncoder(w).Encode(metricsManager.GetMetrics())
        }</span>)

        // Config endpoint
        <span class="cov0" title="0">http.HandleFunc("/api/config", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "server": map[string]interface{}{
                                "addr": ":9001", // QUIC Testing Tool —Å–µ—Ä–≤–µ—Ä (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π –ø–æ—Ä—Ç)
                                "cert": "server.crt",
                                "key":  "server.key",
                        },
                        "client": map[string]interface{}{
                                "addr":        "localhost:9001", // QUIC Testing Tool –∫–ª–∏–µ–Ω—Ç (—É–Ω–∏–∫–∞–ª—å–Ω—ã–π –ø–æ—Ä—Ç)
                                "connections": 1,
                                "streams":     1,
                                "packetSize":  1200,
                                "rate":        100,
                                "pattern":     "random",
                        },
                })
        }</span>)

        // QUIC Server API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/server/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StartServer()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "started",
                                "message": "QUIC server started on port 9001",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        <span class="cov0" title="0">http.HandleFunc("/api/server/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StopServer()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "stopped",
                                "message": "QUIC server stopped",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        // QUIC Client API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/client/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StartClient()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "started",
                                "message": "QUIC client connected to localhost:9001",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        <span class="cov0" title="0">http.HandleFunc("/api/client/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        err := quicManager.StopClient()
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "stopped",
                                "message": "QUIC client disconnected",
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        // QUIC Test API endpoint
        <span class="cov0" title="0">http.HandleFunc("/api/test/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                if quicManager != nil </span><span class="cov0" title="0">{
                        // –ü–∞—Ä—Å–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Å—Ç–∞ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
                        var testParams struct {
                                PacketSize  int `json:"packet_size"`
                                PacketCount int `json:"packet_count"`
                                Duration    int `json:"duration"` // –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
                        }

                        if err := json.NewDecoder(r.Body).Decode(&amp;testParams); err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": "Invalid test parameters",
                                })
                                return
                        }</span>

                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                        <span class="cov0" title="0">if testParams.PacketSize == 0 </span><span class="cov0" title="0">{
                                testParams.PacketSize = 1200
                        }</span>
                        <span class="cov0" title="0">if testParams.PacketCount == 0 </span><span class="cov0" title="0">{
                                testParams.PacketCount = 10
                        }</span>
                        <span class="cov0" title="0">if testParams.Duration == 0 </span><span class="cov0" title="0">{
                                testParams.Duration = 30
                        }</span>

                        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Ç–µ—Å—Ç–∞
                        <span class="cov0" title="0">testConfig := &amp;quic.TestConfig{
                                PacketSize:  testParams.PacketSize,
                                PacketCount: testParams.PacketCount,
                                Duration:    time.Duration(testParams.Duration) * time.Second,
                        }

                        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç
                        ctx := context.Background()
                        err := quicManager.RunTest(ctx, testConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "status":  "error",
                                        "message": err.Error(),
                                })
                                return
                        }</span>

                        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "started",
                                "message": "QUIC test started",
                                "config":  testConfig,
                        })</span>
                } else<span class="cov0" title="0"> {
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "status":  "error",
                                "message": "QUIC manager not initialized",
                        })
                }</span>
        })

        // MASQUE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/masque/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetMASQUEActive(true)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "MASQUE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/masque/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetMASQUEActive(false)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "MASQUE testing stopped",
                })
        }</span>)

        // ICE API endpoints
        <span class="cov0" title="0">http.HandleFunc("/api/ice/start", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetICEActive(true)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "started",
                        "message": "ICE testing started",
                })
        }</span>)

        <span class="cov0" title="0">http.HandleFunc("/api/ice/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                metricsManager.SetICEActive(false)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "status":  "stopped",
                        "message": "ICE testing stopped",
                })
        }</span>)

        // History endpoint –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤
        <span class="cov0" title="0">http.HandleFunc("/api/history", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(metricsManager.GetHistory())
        }</span>)

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä
        <span class="cov0" title="0">log.Fatal(http.ListenAndServe(":9990", nil))
        return nil</span>
}

// runMASQUE –∑–∞–ø—É—Å–∫–∞–µ—Ç MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runMASQUE(args []string) error <span class="cov0" title="0">{
        fmt.Println("üî• –ó–∞–ø—É—Å–∫ MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è...")
        // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ cmd/masque
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        return nil
}</span>

// runICE –∑–∞–ø—É—Å–∫–∞–µ—Ç ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runICE(args []string) error <span class="cov0" title="0">{
        fmt.Println("üßä –ó–∞–ø—É—Å–∫ ICE/STUN/TURN —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è...")
        // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ cmd/ice
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        return nil
}</span>

// runEnhanced –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func runEnhanced(args []string) error <span class="cov0" title="0">{
        fmt.Println("üöÄ –ó–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (MASQUE + ICE + QUIC)...")
        // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ cmd/enhanced
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package dashboard

import (
        "math"
        "math/rand"
        "sync"
        "time"
)

// MetricsManager —É–ø—Ä–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∞–º–∏ dashboard
type MetricsManager struct {
        mu sync.RWMutex

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        ServerRunning bool
        ClientRunning bool

        // MASQUE —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        MASQUEActive bool
        MASQUETests  int64

        // ICE —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        ICEActive bool
        ICETests  int64

        // –ë–∞–∑–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        Latency       float64
        Throughput    float64
        PacketLoss    float64
        Connections   int64
        Retransmits   int64
        HandshakeTime float64

        // –ò—Å—Ç–æ—Ä–∏—è –º–µ—Ç—Ä–∏–∫ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤
        LatencyHistory    []float64
        ThroughputHistory []float64
        TimeHistory       []time.Time

        // –°—á–µ—Ç—á–∏–∫–∏
        RequestCount int64
        LastUpdate   time.Time
}

// NewMetricsManager —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –º–µ—Ç—Ä–∏–∫
func NewMetricsManager() *MetricsManager <span class="cov0" title="0">{
        return &amp;MetricsManager{
                LatencyHistory:    make([]float64, 0, 100),
                ThroughputHistory: make([]float64, 0, 100),
                TimeHistory:       make([]time.Time, 0, 100),
                LastUpdate:        time.Now(),
        }
}</span>

// UpdateMetrics –æ–±–Ω–æ–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏
func (mm *MetricsManager) UpdateMetrics() <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()

        now := time.Now()
        mm.RequestCount++
        mm.LastUpdate = now

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        if mm.ServerRunning &amp;&amp; mm.ClientRunning </span><span class="cov0" title="0">{
                // –ê–∫—Ç–∏–≤–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ - –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
                mm.Latency = 20 + rand.Float64()*30       // 20-50ms
                mm.Throughput = 100 + rand.Float64()*200  // 100-300 Mbps
                mm.PacketLoss = rand.Float64() * 2        // 0-2%
                mm.Connections = 1 + rand.Int63n(10)      // 1-10 —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
                mm.Retransmits = rand.Int63n(5)           // 0-5 retransmits
                mm.HandshakeTime = 30 + rand.Float64()*50 // 30-80ms
        }</span> else<span class="cov0" title="0"> if mm.MASQUEActive </span><span class="cov0" title="0">{
                // MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
                mm.Latency = 15 + rand.Float64()*25       // 15-40ms
                mm.Throughput = 80 + rand.Float64()*120   // 80-200 Mbps
                mm.PacketLoss = rand.Float64() * 1.5      // 0-1.5%
                mm.Connections = 1 + rand.Int63n(5)       // 1-5 —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
                mm.Retransmits = rand.Int63n(3)           // 0-3 retransmits
                mm.HandshakeTime = 25 + rand.Float64()*40 // 25-65ms
        }</span> else<span class="cov0" title="0"> if mm.ICEActive </span><span class="cov0" title="0">{
                // ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
                mm.Latency = 30 + rand.Float64()*40       // 30-70ms
                mm.Throughput = 60 + rand.Float64()*100   // 60-160 Mbps
                mm.PacketLoss = rand.Float64() * 3        // 0-3%
                mm.Connections = 1 + rand.Int63n(3)       // 1-3 —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
                mm.Retransmits = rand.Int63n(8)           // 0-8 retransmits
                mm.HandshakeTime = 40 + rand.Float64()*60 // 40-100ms
        }</span> else<span class="cov0" title="0"> {
                // –ù–µ–∞–∫—Ç–∏–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ - –Ω–∏–∑–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
                mm.Latency = 5 + rand.Float64()*10     // 5-15ms
                mm.Throughput = 10 + rand.Float64()*20 // 10-30 Mbps
                mm.PacketLoss = rand.Float64() * 0.5   // 0-0.5%
                mm.Connections = 0
                mm.Retransmits = 0
                mm.HandshakeTime = 10 + rand.Float64()*20 // 10-30ms
        }</span>

        // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        <span class="cov0" title="0">mm.LatencyHistory = append(mm.LatencyHistory, mm.Latency)
        mm.ThroughputHistory = append(mm.ThroughputHistory, mm.Throughput)
        mm.TimeHistory = append(mm.TimeHistory, now)

        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
        if len(mm.LatencyHistory) &gt; 100 </span><span class="cov0" title="0">{
                mm.LatencyHistory = mm.LatencyHistory[1:]
                mm.ThroughputHistory = mm.ThroughputHistory[1:]
                mm.TimeHistory = mm.TimeHistory[1:]
        }</span>
}

// GetMetrics –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏
func (mm *MetricsManager) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        return map[string]interface{}{
                "latency": map[string]interface{}{
                        "value": math.Round(mm.Latency*10) / 10,
                        "unit":  "ms",
                },
                "throughput": map[string]interface{}{
                        "value": math.Round(mm.Throughput*10) / 10,
                        "unit":  "Mbps",
                },
                "packetLoss": map[string]interface{}{
                        "value": math.Round(mm.PacketLoss*100) / 100,
                        "unit":  "%",
                },
                "connections": map[string]interface{}{
                        "value": mm.Connections,
                        "unit":  "",
                },
                "retransmits": map[string]interface{}{
                        "value": mm.Retransmits,
                        "unit":  "",
                },
                "handshakeTime": map[string]interface{}{
                        "value": math.Round(mm.HandshakeTime*10) / 10,
                        "unit":  "ms",
                },
                "server_running": mm.ServerRunning,
                "client_running": mm.ClientRunning,
                "masque_active":  mm.MASQUEActive,
                "ice_active":     mm.ICEActive,
                "request_count":  mm.RequestCount,
                "last_update":    mm.LastUpdate,
        }
}</span>

// GetHistory –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –º–µ—Ç—Ä–∏–∫
func (mm *MetricsManager) GetHistory() map[string]interface{} <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()

        // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 20 —Ç–æ—á–µ–∫
        start := 0
        if len(mm.LatencyHistory) &gt; 20 </span><span class="cov0" title="0">{
                start = len(mm.LatencyHistory) - 20
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "latency":    mm.LatencyHistory[start:],
                "throughput": mm.ThroughputHistory[start:],
                "time":       mm.TimeHistory[start:],
        }</span>
}

// SetServerRunning —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä–∞
func (mm *MetricsManager) SetServerRunning(running bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.ServerRunning = running
}</span>

// SetClientRunning —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞
func (mm *MetricsManager) SetClientRunning(running bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.ClientRunning = running
}</span>

// SetMASQUEActive —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ MASQUE
func (mm *MetricsManager) SetMASQUEActive(active bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.MASQUEActive = active
        if active </span><span class="cov0" title="0">{
                mm.MASQUETests++
        }</span>
}

// SetICEActive —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ ICE
func (mm *MetricsManager) SetICEActive(active bool) <span class="cov0" title="0">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        mm.ICEActive = active
        if active </span><span class="cov0" title="0">{
                mm.ICETests++
        }</span>
}

</pre>
		
		<pre class="file" id="file9" style="display: none">package ice

import (
        "context"
        "fmt"
        "net"
        "sync"
        "time"

        "github.com/pion/ice/v2"
        "github.com/pion/stun"
        "go.uber.org/zap"
)

// ICETester —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç ICE/STUN/TURN —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
type ICETester struct {
        logger *zap.Logger
        config *ICEConfig

        // ICE –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        agent *ice.Agent
        conn  *ice.Conn

        // STUN/TURN —Å–µ—Ä–≤–µ—Ä—ã
        stunServers []string
        turnServers []string

        // –ú–µ—Ç—Ä–∏–∫–∏
        metrics *ICEMetrics
        stats   *ICEStats

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ
        mu       sync.RWMutex
        isActive bool
}

// ICEConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type ICEConfig struct {
        // STUN —Å–µ—Ä–≤–µ—Ä—ã
        StunServers []string `json:"stun_servers"`

        // TURN —Å–µ—Ä–≤–µ—Ä—ã
        TurnServers []string `json:"turn_servers"`

        // TURN –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
        TurnUsername string `json:"turn_username"`
        TurnPassword string `json:"turn_password"`

        // –¢–∞–π–º–∞—É—Ç—ã
        GatheringTimeout time.Duration `json:"gathering_timeout"`
        ConnectionTimeout time.Duration `json:"connection_timeout"`

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        TestDuration time.Duration `json:"test_duration"`
        ConcurrentTests int `json:"concurrent_tests"`
}

// ICEMetrics –º–µ—Ç—Ä–∏–∫–∏ ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type ICEMetrics struct {
        // STUN –º–µ—Ç—Ä–∏–∫–∏
        StunRequests     int64 `json:"stun_requests"`
        StunResponses    int64 `json:"stun_responses"`
        StunLatency      time.Duration `json:"stun_latency"`

        // TURN –º–µ—Ç—Ä–∏–∫–∏
        TurnAllocations  int64 `json:"turn_allocations"`
        TurnSuccesses    int64 `json:"turn_successes"`
        TurnFailures     int64 `json:"turn_failures"`
        TurnLatency      time.Duration `json:"turn_latency"`

        // ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
        CandidatesGathered int64 `json:"candidates_gathered"`
        HostCandidates     int64 `json:"host_candidates"`
        ServerReflexiveCandidates int64 `json:"server_reflexive_candidates"`
        RelayCandidates    int64 `json:"relay_candidates"`

        // ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        ConnectionsAttempted int64 `json:"connections_attempted"`
        ConnectionsSuccessful int64 `json:"connections_successful"`
        ConnectionsFailed   int64 `json:"connections_failed"`
        ConnectionLatency   time.Duration `json:"connection_latency"`

        // –û–±—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏
        TotalTests        int64 `json:"total_tests"`
        SuccessfulTests   int64 `json:"successful_tests"`
        FailedTests       int64 `json:"failed_tests"`
        SuccessRate       float64 `json:"success_rate"`
}

// ICEStats —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type ICEStats struct {
        StartTime    time.Time `json:"start_time"`
        EndTime      time.Time `json:"end_time"`
        Duration     time.Duration `json:"duration"`
        TestsRun     int `json:"tests_run"`
        TestsPassed  int `json:"tests_passed"`
        TestsFailed  int `json:"tests_failed"`
        SuccessRate  float64 `json:"success_rate"`
}

// NewICETester —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π ICE —Ç–µ—Å—Ç–µ—Ä
func NewICETester(logger *zap.Logger, config *ICEConfig) *ICETester <span class="cov0" title="0">{
        return &amp;ICETester{
                logger: logger,
                config: config,
                metrics: &amp;ICEMetrics{},
                stats:   &amp;ICEStats{},
        }
}</span>

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func (it *ICETester) Start(ctx context.Context) error <span class="cov0" title="0">{
        it.mu.Lock()
        defer it.mu.Unlock()

        if it.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("ICE tester is already active")
        }</span>

        <span class="cov0" title="0">it.logger.Info("Starting ICE testing",
                zap.Strings("stun_servers", it.config.StunServers),
                zap.Strings("turn_servers", it.config.TurnServers))

        it.isActive = true
        it.stats.StartTime = time.Now()

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º ICE agent
        if err := it.initializeICEAgent(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize ICE agent: %v", err)
        }</span>

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">go it.runTests(ctx)

        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func (it *ICETester) Stop() error <span class="cov0" title="0">{
        it.mu.Lock()
        defer it.mu.Unlock()

        if !it.isActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">it.logger.Info("Stopping ICE testing")
        it.isActive = false
        it.stats.EndTime = time.Now()
        it.stats.Duration = it.stats.EndTime.Sub(it.stats.StartTime)

        // –ó–∞–∫—Ä—ã–≤–∞–µ–º ICE agent
        if it.agent != nil </span><span class="cov0" title="0">{
                it.agent.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// initializeICEAgent –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç ICE agent
func (it *ICETester) initializeICEAgent() error <span class="cov0" title="0">{
        it.logger.Info("Initializing ICE agent")

        // –°–æ–∑–¥–∞–µ–º STUN/TURN URLs
        urls := make([]*stun.URI, 0)

        // –î–æ–±–∞–≤–ª—è–µ–º STUN —Å–µ—Ä–≤–µ—Ä—ã
        for _, server := range it.config.StunServers </span><span class="cov0" title="0">{
                url, err := stun.ParseURI(fmt.Sprintf("stun:%s", server))
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Warn("Failed to parse STUN server URL", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">urls = append(urls, url)</span>
        }

        // –î–æ–±–∞–≤–ª—è–µ–º TURN —Å–µ—Ä–≤–µ—Ä—ã
        <span class="cov0" title="0">for _, server := range it.config.TurnServers </span><span class="cov0" title="0">{
                url, err := stun.ParseURI(fmt.Sprintf("turn:%s", server))
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Warn("Failed to parse TURN server URL", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">urls = append(urls, url)</span>
        }

        // –°–æ–∑–¥–∞–µ–º ICE agent –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        <span class="cov0" title="0">iceConfig := &amp;ice.AgentConfig{
                NetworkTypes: []ice.NetworkType{ice.NetworkTypeUDP4, ice.NetworkTypeUDP6},
                Urls:         urls,
        }

        // –°–æ–∑–¥–∞–µ–º ICE agent
        agent, err := ice.NewAgent(iceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ICE agent: %v", err)
        }</span>

        <span class="cov0" title="0">it.agent = agent

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        if err := it.setupEventHandlers(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup event handlers: %v", err)
        }</span>

        <span class="cov0" title="0">it.logger.Info("ICE agent initialized successfully")
        return nil</span>
}

// setupEventHandlers –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π ICE
func (it *ICETester) setupEventHandlers() error <span class="cov0" title="0">{
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–æ–≤—ã—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
        if err := it.agent.OnCandidate(func(c ice.Candidate) </span><span class="cov0" title="0">{
                if c == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">it.logger.Debug("ICE candidate gathered",
                        zap.String("candidate", c.String()),
                        zap.String("type", c.Type().String()),
                        zap.String("address", c.Address()),
                        zap.Int("port", c.Port()))

                it.metrics.CandidatesGathered++

                // –ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
                switch c.Type() </span>{
                case ice.CandidateTypeHost:<span class="cov0" title="0">
                        it.metrics.HostCandidates++</span>
                case ice.CandidateTypeServerReflexive:<span class="cov0" title="0">
                        it.metrics.ServerReflexiveCandidates++</span>
                case ice.CandidateTypeRelay:<span class="cov0" title="0">
                        it.metrics.RelayCandidates++</span>
                }
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        <span class="cov0" title="0">if err := it.agent.OnConnectionStateChange(func(c ice.ConnectionState) </span><span class="cov0" title="0">{
                it.logger.Info("ICE connection state changed", zap.String("state", c.String()))

                switch c </span>{
                case ice.ConnectionStateConnected:<span class="cov0" title="0">
                        it.metrics.ConnectionsSuccessful++
                        it.logger.Info("ICE connection established successfully")</span>
                case ice.ConnectionStateDisconnected:<span class="cov0" title="0">
                        it.logger.Warn("ICE connection disconnected")</span>
                case ice.ConnectionStateFailed:<span class="cov0" title="0">
                        it.metrics.ConnectionsFailed++
                        it.logger.Error("ICE connection failed")</span>
                }
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// runTests –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ ICE —Ç–µ—Å—Ç—ã
func (it *ICETester) runTests(ctx context.Context) <span class="cov0" title="0">{
        it.logger.Info("Running ICE tests")

        // STUN —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        it.logger.Info("Testing STUN functionality")
        if err := it.testSTUN(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("STUN testing failed", zap.Error(err))
        }</span>

        // TURN —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">it.logger.Info("Testing TURN functionality")
        if err := it.testTURN(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("TURN testing failed", zap.Error(err))
        }</span>

        // ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">it.logger.Info("Testing ICE candidate gathering")
        if err := it.testCandidateGathering(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("ICE candidate gathering testing failed", zap.Error(err))
        }</span>

        // ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">it.logger.Info("Testing ICE connections")
        if err := it.testICEConnections(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("ICE connections testing failed", zap.Error(err))
        }</span>

        // NAT traversal —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">it.logger.Info("Testing NAT traversal")
        if err := it.testNATTraversal(ctx); err != nil </span><span class="cov0" title="0">{
                it.logger.Error("NAT traversal testing failed", zap.Error(err))
        }</span>

        <span class="cov0" title="0">it.logger.Info("ICE testing completed")</span>
}

// testSTUN —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç STUN —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
func (it *ICETester) testSTUN(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing STUN servers")

        for _, server := range it.config.StunServers </span><span class="cov0" title="0">{
                it.logger.Info("Testing STUN server", zap.String("server", server))
                
                start := time.Now()
                
                // –°–æ–∑–¥–∞–µ–º STUN –∫–ª–∏–µ–Ω—Ç
                conn, err := net.Dial("udp", server)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to connect to STUN server", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">defer conn.Close()

                // –°–æ–∑–¥–∞–µ–º STUN Binding Request
                request := stun.MustBuild(stun.TransactionID, stun.BindingRequest)
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
                _, err = conn.Write(request.Raw)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to send STUN request", zap.String("server", server), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.StunRequests++

                // –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
                response := make([]byte, 1024)
                conn.SetReadDeadline(time.Now().Add(5 * time.Second))
                _, err = conn.Read(response)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to receive STUN response", zap.String("server", server), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.StunResponses++
                it.metrics.StunLatency = time.Since(start)

                it.logger.Info("STUN test completed",
                        zap.String("server", server),
                        zap.Duration("latency", it.metrics.StunLatency))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testTURN —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç TURN —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
func (it *ICETester) testTURN(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing TURN servers")

        for _, server := range it.config.TurnServers </span><span class="cov0" title="0">{
                it.logger.Info("Testing TURN server", zap.String("server", server))
                
                start := time.Now()
                
                // –°–æ–∑–¥–∞–µ–º TURN –∫–ª–∏–µ–Ω—Ç
                conn, err := net.Dial("udp", server)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to connect to TURN server", zap.String("server", server), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">defer conn.Close()

                // –°–æ–∑–¥–∞–µ–º TURN Allocation Request
                request := stun.MustBuild(
                        stun.TransactionID,
                        stun.NewType(stun.MethodAllocate, stun.ClassRequest),
                        stun.Username(it.config.TurnUsername),
                )
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
                _, err = conn.Write(request.Raw)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to send TURN request", zap.String("server", server), zap.Error(err))
                        it.metrics.TurnFailures++
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.TurnAllocations++

                // –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
                response := make([]byte, 1024)
                conn.SetReadDeadline(time.Now().Add(10 * time.Second))
                _, err = conn.Read(response)
                if err != nil </span><span class="cov0" title="0">{
                        it.logger.Error("Failed to receive TURN response", zap.String("server", server), zap.Error(err))
                        it.metrics.TurnFailures++
                        continue</span>
                }

                <span class="cov0" title="0">it.metrics.TurnSuccesses++
                it.metrics.TurnLatency = time.Since(start)

                it.logger.Info("TURN test completed",
                        zap.String("server", server),
                        zap.Duration("latency", it.metrics.TurnLatency))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testCandidateGathering —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç —Å–±–æ—Ä ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
func (it *ICETester) testCandidateGathering(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing ICE candidate gathering")

        // –ù–∞—á–∏–Ω–∞–µ–º —Å–±–æ—Ä –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
        if err := it.agent.GatherCandidates(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to gather candidates: %v", err)
        }</span>

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–±–æ—Ä–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
        <span class="cov0" title="0">timeout := time.NewTimer(it.config.GatheringTimeout)
        defer timeout.Stop()

        select </span>{
        case &lt;-timeout.C:<span class="cov0" title="0">
                it.logger.Info("Candidate gathering timeout reached")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }

        <span class="cov0" title="0">it.logger.Info("ICE candidate gathering completed",
                zap.Int64("candidates_gathered", it.metrics.CandidatesGathered),
                zap.Int64("host_candidates", it.metrics.HostCandidates),
                zap.Int64("server_reflexive_candidates", it.metrics.ServerReflexiveCandidates),
                zap.Int64("relay_candidates", it.metrics.RelayCandidates))

        return nil</span>
}

// testICEConnections —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (it *ICETester) testICEConnections(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing ICE connections")

        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–æ –±—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —É–¥–∞–ª–µ–Ω–Ω—ã–º peer
        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–º–∏—Ç–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        
        it.metrics.ConnectionsAttempted++
        
        // –ò–º–∏—Ç–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        time.Sleep(100 * time.Millisecond)
        it.metrics.ConnectionsSuccessful++
        it.metrics.ConnectionLatency = 100 * time.Millisecond

        it.logger.Info("ICE connection test completed",
                zap.Int64("connections_attempted", it.metrics.ConnectionsAttempted),
                zap.Int64("connections_successful", it.metrics.ConnectionsSuccessful))

        return nil
}</span>

// testNATTraversal —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç NAT traversal
func (it *ICETester) testNATTraversal(ctx context.Context) error <span class="cov0" title="0">{
        it.logger.Info("Testing NAT traversal")

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ NAT
        scenarios := []string{
                "Full Cone NAT",
                "Restricted Cone NAT", 
                "Port Restricted Cone NAT",
                "Symmetric NAT",
        }

        for _, scenario := range scenarios </span><span class="cov0" title="0">{
                it.logger.Info("Testing NAT scenario", zap.String("scenario", scenario))
                
                // –ò–º–∏—Ç–∏—Ä—É–µ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ NAT traversal
                time.Sleep(50 * time.Millisecond)
                
                it.logger.Info("NAT traversal test completed", zap.String("scenario", scenario))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetMetrics –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
func (it *ICETester) GetMetrics() *ICEMetrics <span class="cov0" title="0">{
        it.mu.RLock()
        defer it.mu.RUnlock()
        return it.metrics
}</span>

// GetStats –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
func (it *ICETester) GetStats() *ICEStats <span class="cov0" title="0">{
        it.mu.RLock()
        defer it.mu.RUnlock()
        return it.stats
}</span>

// IsActive –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–µ—Å—Ç–µ—Ä–∞
func (it *ICETester) IsActive() bool <span class="cov0" title="0">{
        it.mu.RLock()
        defer it.mu.RUnlock()
        return it.isActive
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package integration

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"

        "quic-test/internal/ice"
        "quic-test/internal/masque"
)

// EnhancedTester –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç MASQUE –∏ ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º QUIC —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
type EnhancedTester struct {
        logger *zap.Logger

        // –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        masqueTester *masque.MASQUETester
        iceTester    *ice.ICETester

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        config *EnhancedConfig

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ
        mu       sync.RWMutex
        isActive bool
        startTime time.Time
}

// EnhancedConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type EnhancedConfig struct {
        // MASQUE –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        MASQUE masque.MASQUEConfig `json:"masque"`

        // ICE –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        ICE ice.ICEConfig `json:"ice"`

        // –û–±—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        TestDuration    time.Duration `json:"test_duration"`
        ConcurrentTests int           `json:"concurrent_tests"`
        EnableMASQUE    bool          `json:"enable_masque"`
        EnableICE       bool          `json:"enable_ice"`
}

// EnhancedMetrics –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
type EnhancedMetrics struct {
        // MASQUE –º–µ—Ç—Ä–∏–∫–∏
        MASQUE *masque.MASQUEMetrics `json:"masque"`

        // ICE –º–µ—Ç—Ä–∏–∫–∏
        ICE *ice.ICEMetrics `json:"ice"`

        // –û–±—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏
        TotalTests      int64         `json:"total_tests"`
        SuccessfulTests int64         `json:"successful_tests"`
        FailedTests     int64         `json:"failed_tests"`
        SuccessRate     float64       `json:"success_rate"`
        TestDuration    time.Duration `json:"test_duration"`
        StartTime       time.Time     `json:"start_time"`
        EndTime         time.Time     `json:"end_time"`
}

// NewEnhancedTester —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ç–µ—Å—Ç–µ—Ä
func NewEnhancedTester(logger *zap.Logger, config *EnhancedConfig) *EnhancedTester <span class="cov0" title="0">{
        return &amp;EnhancedTester{
                logger: logger,
                config: config,
        }
}</span>

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func (et *EnhancedTester) Start(ctx context.Context) error <span class="cov0" title="0">{
        et.mu.Lock()
        defer et.mu.Unlock()

        if et.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("enhanced tester is already active")
        }</span>

        <span class="cov0" title="0">et.logger.Info("Starting enhanced testing",
                zap.Bool("masque_enabled", et.config.EnableMASQUE),
                zap.Bool("ice_enabled", et.config.EnableICE),
                zap.Duration("test_duration", et.config.TestDuration))

        et.isActive = true
        et.startTime = time.Now()

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        if et.config.EnableMASQUE </span><span class="cov0" title="0">{
                et.logger.Info("Initializing MASQUE testing")
                et.masqueTester = masque.NewMASQUETester(et.logger, &amp;et.config.MASQUE)
                
                if err := et.masqueTester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to start MASQUE testing", zap.Error(err))
                        return fmt.Errorf("failed to start MASQUE testing: %v", err)
                }</span>
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">if et.config.EnableICE </span><span class="cov0" title="0">{
                et.logger.Info("Initializing ICE testing")
                et.iceTester = ice.NewICETester(et.logger, &amp;et.config.ICE)
                
                if err := et.iceTester.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to start ICE testing", zap.Error(err))
                        return fmt.Errorf("failed to start ICE testing: %v", err)
                }</span>
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
        <span class="cov0" title="0">go et.monitorTests(ctx)

        et.logger.Info("Enhanced testing started successfully")
        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func (et *EnhancedTester) Stop() error <span class="cov0" title="0">{
        et.mu.Lock()
        defer et.mu.Unlock()

        if !et.isActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">et.logger.Info("Stopping enhanced testing")

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        if et.masqueTester != nil </span><span class="cov0" title="0">{
                if err := et.masqueTester.Stop(); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to stop MASQUE testing", zap.Error(err))
                }</span>
        }

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ICE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">if et.iceTester != nil </span><span class="cov0" title="0">{
                if err := et.iceTester.Stop(); err != nil </span><span class="cov0" title="0">{
                        et.logger.Error("Failed to stop ICE testing", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">et.isActive = false
        et.logger.Info("Enhanced testing stopped")
        return nil</span>
}

// monitorTests –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤
func (et *EnhancedTester) monitorTests(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        et.logTestStatus()</span>
                }
        }
}

// logTestStatus –ª–æ–≥–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç—É—Å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
func (et *EnhancedTester) logTestStatus() <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()

        et.logger.Info("Test status",
                zap.Bool("masque_active", et.masqueTester != nil &amp;&amp; et.masqueTester.IsActive()),
                zap.Bool("ice_active", et.iceTester != nil &amp;&amp; et.iceTester.IsActive()),
                zap.Duration("elapsed", time.Since(et.startTime)))
}</span>

// GetMetrics –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
func (et *EnhancedTester) GetMetrics() *EnhancedMetrics <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()

        metrics := &amp;EnhancedMetrics{
                StartTime:    et.startTime,
                EndTime:      time.Now(),
                TestDuration: time.Since(et.startTime),
        }

        // –ü–æ–ª—É—á–∞–µ–º MASQUE –º–µ—Ç—Ä–∏–∫–∏
        if et.masqueTester != nil </span><span class="cov0" title="0">{
                metrics.MASQUE = et.masqueTester.GetMetrics()
        }</span>

        // –ü–æ–ª—É—á–∞–µ–º ICE –º–µ—Ç—Ä–∏–∫–∏
        <span class="cov0" title="0">if et.iceTester != nil </span><span class="cov0" title="0">{
                metrics.ICE = et.iceTester.GetMetrics()
        }</span>

        // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏
        <span class="cov0" title="0">if metrics.MASQUE != nil </span><span class="cov0" title="0">{
                metrics.TotalTests += metrics.MASQUE.ConnectUDPRequests + metrics.MASQUE.ConnectIPRequests
                metrics.SuccessfulTests += metrics.MASQUE.ConnectUDPSuccesses + metrics.MASQUE.ConnectIPSuccesses
                metrics.FailedTests += metrics.MASQUE.ConnectUDPFailures + metrics.MASQUE.ConnectIPFailures
        }</span>

        <span class="cov0" title="0">if metrics.ICE != nil </span><span class="cov0" title="0">{
                metrics.TotalTests += metrics.ICE.TotalTests
                metrics.SuccessfulTests += metrics.ICE.SuccessfulTests
                metrics.FailedTests += metrics.ICE.FailedTests
        }</span>

        // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞
        <span class="cov0" title="0">if metrics.TotalTests &gt; 0 </span><span class="cov0" title="0">{
                metrics.SuccessRate = float64(metrics.SuccessfulTests) / float64(metrics.TotalTests) * 100
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

// IsActive –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–µ—Å—Ç–µ—Ä–∞
func (et *EnhancedTester) IsActive() bool <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()
        return et.isActive
}</span>

// GetMASQUETester –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç MASQUE —Ç–µ—Å—Ç–µ—Ä
func (et *EnhancedTester) GetMASQUETester() *masque.MASQUETester <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()
        return et.masqueTester
}</span>

// GetICETester –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç ICE —Ç–µ—Å—Ç–µ—Ä
func (et *EnhancedTester) GetICETester() *ice.ICETester <span class="cov0" title="0">{
        et.mu.RLock()
        defer et.mu.RUnlock()
        return et.iceTester
}</span>

</pre>
		
		<pre class="file" id="file11" style="display: none">package masque

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"
)

// CapsuleTester —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç HTTP Capsules —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å (RFC 9297)
type CapsuleTester struct {
        logger *zap.Logger
        config *MASQUEConfig
}

// Capsule –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç HTTP Capsule
type Capsule struct {
        Type   uint64
        Length uint64
        Value  []byte
}

// Capsule types as defined in RFC 9297
const (
        CapsuleTypeDatagram = 0x00
        CapsuleTypeClose    = 0x01
)

// NewCapsuleTester —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π Capsule —Ç–µ—Å—Ç–µ—Ä
func NewCapsuleTester(logger *zap.Logger, config *MASQUEConfig) *CapsuleTester <span class="cov0" title="0">{
        return &amp;CapsuleTester{
                logger: logger,
                config: config,
        }
}</span>

// TestDatagrams —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç HTTP Datagrams
func (ct *CapsuleTester) TestDatagrams(ctx context.Context, testData []byte) (int64, int64, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing HTTP Datagrams", zap.Int("data_len", len(testData)))

        sent := int64(0)
        received := int64(0)

        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–æ –±—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ä–µ–∞–ª—å–Ω—ã–º HTTP/3 stream
        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ datagrams
        
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É datagrams
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return sent, received, ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // –ò–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É datagram
                        sent++
                        time.Sleep(10 * time.Millisecond) // –ò–º–∏—Ç–∏—Ä—É–µ–º —Å–µ—Ç–µ–≤—É—é –∑–∞–¥–µ—Ä–∂–∫—É
                        
                        // –ò–º–∏—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ datagram (—Å –Ω–µ–±–æ–ª—å—à–æ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é –ø–æ—Ç–µ—Ä–∏)
                        if i%10 != 9 </span><span class="cov0" title="0">{ // 90% —É—Å–ø–µ—à–Ω–æ—Å—Ç—å
                                received++
                        }</span>
                }
        }

        <span class="cov0" title="0">ct.logger.Info("HTTP Datagrams test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received))

        return sent, received, nil</span>
}

// TestCapsules —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç HTTP Capsules
func (ct *CapsuleTester) TestCapsules(ctx context.Context) (int64, int64, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing HTTP Capsules")

        sent := int64(0)
        received := int64(0)

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ capsules
        capsules := []*Capsule{
                {
                        Type:   CapsuleTypeDatagram,
                        Length: 5,
                        Value:  []byte("Hello"),
                },
                {
                        Type:   CapsuleTypeDatagram,
                        Length: 8,
                        Value:  []byte("MASQUE!"),
                },
                {
                        Type:   CapsuleTypeClose,
                        Length: 0,
                        Value:  nil,
                },
        }

        for _, capsule := range capsules </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return sent, received, ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // –ò–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É capsule
                        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                                ct.logger.Error("Failed to send capsule", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">sent++

                        // –ò–º–∏—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ capsule
                        time.Sleep(5 * time.Millisecond)
                        received++</span>
                }
        }

        <span class="cov0" title="0">ct.logger.Info("HTTP Capsules test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received))

        return sent, received, nil</span>
}

// TestThroughput —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–ø—É—Å–∫–Ω—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å
func (ct *CapsuleTester) TestThroughput(ctx context.Context, duration time.Duration) (float64, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing throughput", zap.Duration("duration", duration))

        start := time.Now()
        bytesSent := int64(0)
        
        // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        testData := make([]byte, 1024)
        for i := range testData </span><span class="cov0" title="0">{
                testData[i] = byte(i % 256)
        }</span>

        <span class="cov0" title="0">for time.Since(start) &lt; duration </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return 0, ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // –°–æ–∑–¥–∞–µ–º datagram capsule
                        capsule := &amp;Capsule{
                                Type:   CapsuleTypeDatagram,
                                Length: uint64(len(testData)),
                                Value:  testData,
                        }

                        // –ò–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É
                        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                                ct.logger.Error("Failed to send capsule", zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">bytesSent += int64(len(testData))
                        time.Sleep(1 * time.Millisecond)</span> // –ò–º–∏—Ç–∏—Ä—É–µ–º —Å–µ—Ç–µ–≤—É—é –∑–∞–¥–µ—Ä–∂–∫—É
                }
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        throughput := float64(bytesSent) / elapsed.Seconds() / (1024 * 1024) // MB/s

        ct.logger.Info("Throughput test completed",
                zap.Float64("throughput_mbps", throughput),
                zap.Int64("bytes_sent", bytesSent))

        return throughput, nil</span>
}

// TestLatency —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –∑–∞–¥–µ—Ä–∂–∫—É
func (ct *CapsuleTester) TestLatency(ctx context.Context) (time.Duration, error) <span class="cov0" title="0">{
        ct.logger.Info("Testing latency")

        testData := []byte("ping")
        
        // –°–æ–∑–¥–∞–µ–º datagram capsule
        capsule := &amp;Capsule{
                Type:   CapsuleTypeDatagram,
                Length: uint64(len(testData)),
                Value:  testData,
        }

        start := time.Now()
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º capsule
        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to send capsule: %v", err)
        }</span>

        // –ò–º–∏—Ç–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
        <span class="cov0" title="0">time.Sleep(5 * time.Millisecond)
        
        latency := time.Since(start)

        ct.logger.Info("Latency test completed",
                zap.Duration("latency", latency))

        return latency, nil</span>
}

// sendCapsule –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç HTTP Capsule
func (ct *CapsuleTester) sendCapsule(capsule *Capsule) error <span class="cov0" title="0">{
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –æ—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ HTTP/3 stream
        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–º–∏—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É
        
        ct.logger.Debug("Sending capsule",
                zap.Uint64("type", capsule.Type),
                zap.Uint64("length", capsule.Length))

        // –ò–º–∏—Ç–∏—Ä—É–µ–º —Å–µ—Ç–µ–≤—É—é –∑–∞–¥–µ—Ä–∂–∫—É
        time.Sleep(1 * time.Millisecond)
        
        return nil
}</span>

// parseCapsule –ø–∞—Ä—Å–∏—Ç HTTP Capsule –∏–∑ –¥–∞–Ω–Ω—ã—Ö
func (ct *CapsuleTester) parseCapsule(data []byte) (*Capsule, error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty capsule data")
        }</span>

        // –ü–∞—Ä—Å–∏–º —Ç–∏–ø capsule
        <span class="cov0" title="0">if len(data) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid capsule: too short")
        }</span>

        // –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        <span class="cov0" title="0">capsuleType := uint64(data[0])
        n := 1

        // –ü–∞—Ä—Å–∏–º –¥–ª–∏–Ω—É
        if len(data) &lt; n+1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid capsule: length too short")
        }</span>

        <span class="cov0" title="0">capsuleLength := uint64(data[n])
        m := 1

        // –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
        valueStart := n + m
        if len(data) &lt; valueStart+int(capsuleLength) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid capsule: value too short")
        }</span>

        <span class="cov0" title="0">value := make([]byte, capsuleLength)
        if capsuleLength &gt; 0 </span><span class="cov0" title="0">{
                copy(value, data[valueStart:valueStart+int(capsuleLength)])
        }</span>

        <span class="cov0" title="0">return &amp;Capsule{
                Type:   capsuleType,
                Length: capsuleLength,
                Value:  value,
        }, nil</span>
}

// writeCapsule –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç HTTP Capsule –≤ –±—É—Ñ–µ—Ä
func (ct *CapsuleTester) writeCapsule(capsule *Capsule) ([]byte, error) <span class="cov0" title="0">{
        // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        totalSize := 1 + 1 + len(capsule.Value) // type + length + value

        // –°–æ–∑–¥–∞–µ–º –±—É—Ñ–µ—Ä
        buf := make([]byte, totalSize)
        offset := 0

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ç–∏–ø (1 –±–∞–π—Ç)
        buf[offset] = byte(capsule.Type)
        offset++

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–ª–∏–Ω—É (1 –±–∞–π—Ç)
        buf[offset] = byte(capsule.Length)
        offset++

        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
        if len(capsule.Value) &gt; 0 </span><span class="cov0" title="0">{
                copy(buf[offset:], capsule.Value)
        }</span>

        <span class="cov0" title="0">return buf, nil</span>
}

// TestCapsuleFallback —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç fallback —Å DATAGRAM –Ω–∞ Capsules
func (ct *CapsuleTester) TestCapsuleFallback(ctx context.Context) error <span class="cov0" title="0">{
        ct.logger.Info("Testing Capsule fallback mechanism")

        // –ò–º–∏—Ç–∏—Ä—É–µ–º —Å–∏—Ç—É–∞—Ü–∏—é, –∫–æ–≥–¥–∞ DATAGRAM –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        ct.logger.Info("Simulating DATAGRAM unavailability")
        
        // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ Capsules
        ct.logger.Info("Falling back to HTTP Capsules")
        
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —á–µ—Ä–µ–∑ Capsules
        testData := []byte("fallback test")
        capsule := &amp;Capsule{
                Type:   CapsuleTypeDatagram,
                Length: uint64(len(testData)),
                Value:  testData,
        }

        if err := ct.sendCapsule(capsule); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send fallback capsule: %v", err)
        }</span>

        <span class="cov0" title="0">ct.logger.Info("Capsule fallback test completed successfully")
        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç Capsule —Ç–µ—Å—Ç–µ—Ä
func (ct *CapsuleTester) Stop() error <span class="cov0" title="0">{
        ct.logger.Info("Stopping Capsule tester")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package masque

import (
        "context"
        "fmt"
        "net"
        "time"

        "go.uber.org/zap"
)

// ConnectIPTester —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç CONNECT-IP —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å (RFC 9484)
type ConnectIPTester struct {
        logger *zap.Logger
        config *MASQUEConfig
}

// ConnectIPConnection –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
type ConnectIPConnection struct {
        targetIP string
        ctx      context.Context
        cancel   context.CancelFunc
        logger   *zap.Logger
}

// NewConnectIPTester —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π CONNECT-IP —Ç–µ—Å—Ç–µ—Ä
func NewConnectIPTester(logger *zap.Logger, config *MASQUEConfig) *ConnectIPTester <span class="cov0" title="0">{
        return &amp;ConnectIPTester{
                logger: logger,
                config: config,
        }
}</span>

// Connect —Å–æ–∑–¥–∞–µ—Ç CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Ü–µ–ª–µ–≤–æ–º—É IP
func (cit *ConnectIPTester) Connect(ctx context.Context, targetIP string) (*ConnectIPConnection, error) <span class="cov0" title="0">{
        cit.logger.Info("Creating CONNECT-IP connection", zap.String("target_ip", targetIP))

        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–∑–¥–∞–µ–º mock —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        connCtx, cancel := context.WithCancel(ctx)

        conn := &amp;ConnectIPConnection{
                targetIP: targetIP,
                ctx:      connCtx,
                cancel:   cancel,
                logger:   cit.logger,
        }

        cit.logger.Info("CONNECT-IP connection established", zap.String("target_ip", targetIP))
        return conn, nil
}</span>

// Write –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (cic *ConnectIPConnection) Write(data []byte) (int, error) <span class="cov0" title="0">{
        // –î–ª—è CONNECT-IP, –¥–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –∫–∞–∫ IP –ø–∞–∫–µ—Ç—ã
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –æ–±—Ä–∞–±–æ—Ç–∫–∞ IP –ø–∞–∫–µ—Ç–æ–≤
        cic.logger.Debug("Sending data via CONNECT-IP",
                zap.String("target_ip", cic.targetIP),
                zap.Int("data_len", len(data)))

        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—Ö
        return len(data), nil
}</span>

// Read —á–∏—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (cic *ConnectIPConnection) Read(data []byte) (int, error) <span class="cov0" title="0">{
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–æ –±—ã —á—Ç–µ–Ω–∏–µ IP –ø–∞–∫–µ—Ç–æ–≤
        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ–º mock –¥–∞–Ω–Ω—ã–µ
        time.Sleep(10 * time.Millisecond) // –ò–º–∏—Ç–∏—Ä—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É —Å–µ—Ç–∏
        
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º echo –¥–∞–Ω–Ω—ã—Ö
        if len(data) &gt; 0 </span><span class="cov0" title="0">{
                data[0] = 'p'
                if len(data) &gt; 1 </span><span class="cov0" title="0">{
                        data[1] = 'o'
                }</span>
                <span class="cov0" title="0">if len(data) &gt; 2 </span><span class="cov0" title="0">{
                        data[2] = 'n'
                }</span>
                <span class="cov0" title="0">if len(data) &gt; 3 </span><span class="cov0" title="0">{
                        data[3] = 'g'
                }</span>
                <span class="cov0" title="0">return 4, nil</span>
        }
        
        <span class="cov0" title="0">return 0, nil</span>
}

// Close –∑–∞–∫—Ä—ã–≤–∞–µ—Ç CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (cic *ConnectIPConnection) Close() error <span class="cov0" title="0">{
        cic.cancel()
        

        return nil
}</span>

// LocalAddr –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å
func (cic *ConnectIPConnection) LocalAddr() net.Addr <span class="cov0" title="0">{
        return &amp;net.IPAddr{IP: net.IPv4zero}
}</span>

// RemoteAddr –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–¥–∞–ª–µ–Ω–Ω—ã–π –∞–¥—Ä–µ—Å
func (cic *ConnectIPConnection) RemoteAddr() net.Addr <span class="cov0" title="0">{
        ip := net.ParseIP(cic.targetIP)
        if ip == nil </span><span class="cov0" title="0">{
                return &amp;net.IPAddr{IP: net.IPv4zero}
        }</span>
        <span class="cov0" title="0">return &amp;net.IPAddr{IP: ip}</span>
}

// SetDeadline —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç deadline
func (cic *ConnectIPConnection) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        // HTTP/3 streams –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç deadlines –Ω–∞–ø—Ä—è–º—É—é
        return nil
}</span>

// SetReadDeadline —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç read deadline
func (cic *ConnectIPConnection) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

// SetWriteDeadline —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç write deadline
func (cic *ConnectIPConnection) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return nil
}</span>

// TestLatency —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –∑–∞–¥–µ—Ä–∂–∫—É CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (cic *ConnectIPConnection) TestLatency() (time.Duration, error) <span class="cov0" title="0">{
        testData := []byte("ping")
        
        start := time.Now()
        _, err := cic.Write(testData)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to send test data: %v", err)
        }</span>

        <span class="cov0" title="0">buffer := make([]byte, len(testData))
        _, err = cic.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to receive test data: %v", err)
        }</span>

        <span class="cov0" title="0">latency := time.Since(start)
        return latency, nil</span>
}

// TestThroughput —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–ø—É—Å–∫–Ω—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (cic *ConnectIPConnection) TestThroughput(duration time.Duration) (float64, error) <span class="cov0" title="0">{
        testData := make([]byte, 1024) // 1KB —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        for i := range testData </span><span class="cov0" title="0">{
                testData[i] = byte(i % 256)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        bytesSent := int64(0)
        
        for time.Since(start) &lt; duration </span><span class="cov0" title="0">{
                _, err := cic.Write(testData)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to send data: %v", err)
                }</span>
                <span class="cov0" title="0">bytesSent += int64(len(testData))</span>
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        throughput := float64(bytesSent) / elapsed.Seconds() / (1024 * 1024) // MB/s

        return throughput, nil</span>
}

// TestIPCapsule —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç IP Capsule —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
func (cic *ConnectIPConnection) TestIPCapsule() error <span class="cov0" title="0">{
        cic.logger.Info("Testing IP Capsule functionality",
                zap.String("target_ip", cic.targetIP))

        // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π IP –ø–∞–∫–µ—Ç (ICMP Echo Request)
        icmpPacket := []byte{
                0x08, 0x00, // Type: Echo Request, Code: 0
                0x00, 0x00, // Checksum (will be calculated)
                0x00, 0x01, // Identifier
                0x00, 0x01, // Sequence Number
                // Data
                0x48, 0x65, 0x6c, 0x6c, 0x6f, // "Hello"
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º IP –ø–∞–∫–µ—Ç
        _, err := cic.Write(icmpPacket)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send IP capsule: %v", err)
        }</span>

        // –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
        <span class="cov0" title="0">response := make([]byte, len(icmpPacket))
        _, err = cic.Read(response)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to receive IP capsule response: %v", err)
        }</span>

        <span class="cov0" title="0">cic.logger.Info("IP Capsule test completed successfully")
        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç CONNECT-IP —Ç–µ—Å—Ç–µ—Ä
func (cit *ConnectIPTester) Stop() error <span class="cov0" title="0">{
        cit.logger.Info("Stopping CONNECT-IP tester")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package masque

import (
        "context"
        "fmt"
        "net"
        "time"

        "go.uber.org/zap"
)

// ConnectUDPTester —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç CONNECT-UDP —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å (RFC 9298)
type ConnectUDPTester struct {
        logger *zap.Logger
        config *MASQUEConfig
}

// ConnectUDPConnection –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
type ConnectUDPConnection struct {
        udpConn  *net.UDPConn
        target   string
        ctx      context.Context
        cancel   context.CancelFunc
}

// NewConnectUDPTester —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π CONNECT-UDP —Ç–µ—Å—Ç–µ—Ä
func NewConnectUDPTester(logger *zap.Logger, config *MASQUEConfig) *ConnectUDPTester <span class="cov0" title="0">{
        return &amp;ConnectUDPTester{
                logger: logger,
                config: config,
        }
}</span>

// Connect —Å–æ–∑–¥–∞–µ—Ç CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ —Ü–µ–ª–µ–≤–æ–º—É —Ö–æ—Å—Ç—É
func (cudt *ConnectUDPTester) Connect(ctx context.Context, target string) (*ConnectUDPConnection, error) <span class="cov0" title="0">{
        cudt.logger.Info("Creating CONNECT-UDP connection", zap.String("target", target))

        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–∑–¥–∞–µ–º mock UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        udpAddr, err := net.ResolveUDPAddr("udp", target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve UDP address: %v", err)
        }</span>

        <span class="cov0" title="0">udpConn, err := net.DialUDP("udp", nil, udpAddr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create UDP connection: %v", err)
        }</span>

        <span class="cov0" title="0">connCtx, cancel := context.WithCancel(ctx)

        conn := &amp;ConnectUDPConnection{
                udpConn: udpConn,
                target:  target,
                ctx:     connCtx,
                cancel:  cancel,
        }

        cudt.logger.Info("CONNECT-UDP connection established", zap.String("target", target))
        return conn, nil</span>
}

// Write –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç UDP datagram —á–µ—Ä–µ–∑ CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (cudc *ConnectUDPConnection) Write(data []byte) (int, error) <span class="cov0" title="0">{
        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        return cudc.udpConn.Write(data)
}</span>

// Read –ø–æ–ª—É—á–∞–µ—Ç UDP datagram —á–µ—Ä–µ–∑ CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (cudc *ConnectUDPConnection) Read(data []byte) (int, error) <span class="cov0" title="0">{
        // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —á–∏—Ç–∞–µ–º –∏–∑ UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        cudc.udpConn.SetReadDeadline(time.Now().Add(5 * time.Second))
        return cudc.udpConn.Read(data)
}</span>

// Close –∑–∞–∫—Ä—ã–≤–∞–µ—Ç CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (cudc *ConnectUDPConnection) Close() error <span class="cov0" title="0">{
        cudc.cancel()
        return cudc.udpConn.Close()
}</span>

// LocalAddr –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å
func (cudc *ConnectUDPConnection) LocalAddr() net.Addr <span class="cov0" title="0">{
        return cudc.udpConn.LocalAddr()
}</span>

// RemoteAddr –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–¥–∞–ª–µ–Ω–Ω—ã–π –∞–¥—Ä–µ—Å
func (cudc *ConnectUDPConnection) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return cudc.udpConn.RemoteAddr()
}</span>

// SetDeadline —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç deadline –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π
func (cudc *ConnectUDPConnection) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return cudc.udpConn.SetDeadline(t)
}</span>

// SetReadDeadline —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç deadline –¥–ª—è —á—Ç–µ–Ω–∏—è
func (cudc *ConnectUDPConnection) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return cudc.udpConn.SetReadDeadline(t)
}</span>

// SetWriteDeadline —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç deadline –¥–ª—è –∑–∞–ø–∏—Å–∏
func (cudc *ConnectUDPConnection) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return cudc.udpConn.SetWriteDeadline(t)
}</span>

// TestConnectUDP —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç CONNECT-UDP —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
func (cudt *ConnectUDPTester) TestConnectUDP(ctx context.Context, target string) error <span class="cov0" title="0">{
        cudt.logger.Info("Testing CONNECT-UDP", zap.String("target", target))

        // –°–æ–∑–¥–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        conn, err := cudt.Connect(ctx, target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create CONNECT-UDP connection: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        testData := []byte("Hello MASQUE CONNECT-UDP!")
        _, err = conn.Write(testData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send data: %v", err)
        }</span>

        // –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
        <span class="cov0" title="0">response := make([]byte, 1024)
        _, err = conn.Read(response)
        if err != nil </span><span class="cov0" title="0">{
                // –î–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –Ω–µ—Ç –æ—Ç–≤–µ—Ç–∞
                cudt.logger.Info("No response received (expected for test)", zap.Error(err))
        }</span>

        <span class="cov0" title="0">cudt.logger.Info("CONNECT-UDP test completed", zap.String("target", target))
        return nil</span>
}

// TestConnectUDPBatch —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (cudt *ConnectUDPTester) TestConnectUDPBatch(ctx context.Context, targets []string) error <span class="cov0" title="0">{
        cudt.logger.Info("Testing CONNECT-UDP batch", zap.Int("targets", len(targets)))

        for _, target := range targets </span><span class="cov0" title="0">{
                if err := cudt.TestConnectUDP(ctx, target); err != nil </span><span class="cov0" title="0">{
                        cudt.logger.Error("CONNECT-UDP test failed", zap.String("target", target), zap.Error(err))
                        continue</span>
                }
        }

        <span class="cov0" title="0">cudt.logger.Info("CONNECT-UDP batch test completed")
        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç CONNECT-UDP —Ç–µ—Å—Ç–µ—Ä
func (cudt *ConnectUDPTester) Stop() error <span class="cov0" title="0">{
        cudt.logger.Info("Stopping CONNECT-UDP tester")
        return nil
}</pre>
		
		<pre class="file" id="file14" style="display: none">package masque

import (
        "context"
        "fmt"
        "net"
        "sync"
        "time"

        "go.uber.org/zap"
)

// MASQUETester —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç MASQUE –ø—Ä–æ—Ç–æ–∫–æ–ª (RFC 9298, RFC 9484)
type MASQUETester struct {
        logger *zap.Logger
        config *MASQUEConfig

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        connectUDPTester *ConnectUDPTester
        connectIPTester  *ConnectIPTester
        capsuleTester    *CapsuleTester

        // –ú–µ—Ç—Ä–∏–∫–∏
        metrics *MASQUEMetrics
        stats   *MASQUEStats

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ
        mu       sync.RWMutex
        isActive bool
}

// MASQUEConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type MASQUEConfig struct {
        // MASQUE —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        ServerURL string `json:"server_url"`

        // –¶–µ–ª–µ–≤—ã–µ —Ö–æ—Å—Ç—ã –¥–ª—è CONNECT-UDP
        UDPTargets []string `json:"udp_targets"`

        // –¶–µ–ª–µ–≤—ã–µ IP –¥–ª—è CONNECT-IP
        IPTargets []string `json:"ip_targets"`

        // TLS –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (—É–ø—Ä–æ—â–µ–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
        TLSConfig interface{} `json:"-"`

        // –¢–∞–π–º–∞—É—Ç—ã
        ConnectTimeout time.Duration `json:"connect_timeout"`
        TestTimeout    time.Duration `json:"test_timeout"`

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        ConcurrentTests int `json:"concurrent_tests"`
        TestDuration    time.Duration `json:"test_duration"`
}

// MASQUEMetrics –º–µ—Ç—Ä–∏–∫–∏ MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type MASQUEMetrics struct {
        // CONNECT-UDP –º–µ—Ç—Ä–∏–∫–∏
        ConnectUDPRequests    int64 `json:"connect_udp_requests"`
        ConnectUDPSuccesses   int64 `json:"connect_udp_successes"`
        ConnectUDPFailures    int64 `json:"connect_udp_failures"`
        ConnectUDPLatency     time.Duration `json:"connect_udp_latency"`

        // CONNECT-IP –º–µ—Ç—Ä–∏–∫–∏
        ConnectIPRequests     int64 `json:"connect_ip_requests"`
        ConnectIPSuccesses    int64 `json:"connect_ip_successes"`
        ConnectIPFailures     int64 `json:"connect_ip_failures"`
        ConnectIPLatency      time.Duration `json:"connect_ip_latency"`

        // HTTP Datagrams –º–µ—Ç—Ä–∏–∫–∏
        DatagramsSent         int64 `json:"datagrams_sent"`
        DatagramsReceived     int64 `json:"datagrams_received"`
        DatagramLossRate      float64 `json:"datagram_loss_rate"`

        // Capsule –º–µ—Ç—Ä–∏–∫–∏
        CapsulesSent          int64 `json:"capsules_sent"`
        CapsulesReceived      int64 `json:"capsules_received"`
        CapsuleFallbackCount  int64 `json:"capsule_fallback_count"`

        // –û–±—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏
        TotalConnections      int64 `json:"total_connections"`
        ActiveConnections     int64 `json:"active_connections"`
        FailedConnections     int64 `json:"failed_connections"`
        AverageLatency        time.Duration `json:"average_latency"`
        Throughput            float64 `json:"throughput_mbps"`
}

// MASQUEStats —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
type MASQUEStats struct {
        StartTime    time.Time `json:"start_time"`
        EndTime      time.Time `json:"end_time"`
        Duration     time.Duration `json:"duration"`
        TestsRun     int `json:"tests_run"`
        TestsPassed  int `json:"tests_passed"`
        TestsFailed  int `json:"tests_failed"`
        SuccessRate  float64 `json:"success_rate"`
}

// NewMASQUETester —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π MASQUE —Ç–µ—Å—Ç–µ—Ä
func NewMASQUETester(logger *zap.Logger, config *MASQUEConfig) *MASQUETester <span class="cov0" title="0">{
        return &amp;MASQUETester{
                logger: logger,
                config: config,
                metrics: &amp;MASQUEMetrics{},
                stats:   &amp;MASQUEStats{},
        }
}</span>

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func (mt *MASQUETester) Start(ctx context.Context) error <span class="cov0" title="0">{
        mt.mu.Lock()
        defer mt.mu.Unlock()

        if mt.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("MASQUE tester is already active")
        }</span>

        <span class="cov0" title="0">mt.logger.Info("Starting MASQUE testing",
                zap.String("server_url", mt.config.ServerURL),
                zap.Int("udp_targets", len(mt.config.UDPTargets)),
                zap.Int("ip_targets", len(mt.config.IPTargets)))

        mt.isActive = true
        mt.stats.StartTime = time.Now()

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        mt.connectUDPTester = NewConnectUDPTester(mt.logger, mt.config)
        mt.connectIPTester = NewConnectIPTester(mt.logger, mt.config)
        mt.capsuleTester = NewCapsuleTester(mt.logger, mt.config)

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        go mt.runTests(ctx)

        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç MASQUE —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
func (mt *MASQUETester) Stop() error <span class="cov0" title="0">{
        mt.mu.Lock()
        defer mt.mu.Unlock()

        if !mt.isActive </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">mt.logger.Info("Stopping MASQUE testing")
        mt.isActive = false
        mt.stats.EndTime = time.Now()
        mt.stats.Duration = mt.stats.EndTime.Sub(mt.stats.StartTime)

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        if mt.connectUDPTester != nil </span><span class="cov0" title="0">{
                mt.connectUDPTester.Stop()
        }</span>
        <span class="cov0" title="0">if mt.connectIPTester != nil </span><span class="cov0" title="0">{
                mt.connectIPTester.Stop()
        }</span>
        <span class="cov0" title="0">if mt.capsuleTester != nil </span><span class="cov0" title="0">{
                mt.capsuleTester.Stop()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// runTests –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ —Ç–µ—Å—Ç—ã MASQUE
func (mt *MASQUETester) runTests(ctx context.Context) <span class="cov0" title="0">{
        mt.logger.Info("Running MASQUE tests")

        // CONNECT-UDP —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        if len(mt.config.UDPTargets) &gt; 0 </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-UDP")
                if err := mt.testConnectUDP(ctx); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("CONNECT-UDP testing failed", zap.Error(err))
                }</span>
        }

        // CONNECT-IP —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">if len(mt.config.IPTargets) &gt; 0 </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-IP")
                if err := mt.testConnectIP(ctx); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("CONNECT-IP testing failed", zap.Error(err))
                }</span>
        }

        // HTTP Datagrams —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">mt.logger.Info("Testing HTTP Datagrams")
        if err := mt.testHTTPDatagrams(ctx); err != nil </span><span class="cov0" title="0">{
                mt.logger.Error("HTTP Datagrams testing failed", zap.Error(err))
        }</span>

        // Capsule fallback —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">mt.logger.Info("Testing Capsule fallback")
        if err := mt.testCapsuleFallback(ctx); err != nil </span><span class="cov0" title="0">{
                mt.logger.Error("Capsule fallback testing failed", zap.Error(err))
        }</span>

        // –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        <span class="cov0" title="0">mt.logger.Info("Testing performance")
        if err := mt.testPerformance(ctx); err != nil </span><span class="cov0" title="0">{
                mt.logger.Error("Performance testing failed", zap.Error(err))
        }</span>

        <span class="cov0" title="0">mt.logger.Info("MASQUE testing completed")</span>
}

// testConnectUDP —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç CONNECT-UDP —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
func (mt *MASQUETester) testConnectUDP(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting CONNECT-UDP tests")

        for _, target := range mt.config.UDPTargets </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-UDP to target", zap.String("target", target))
                
                // –°–æ–∑–¥–∞–µ–º CONNECT-UDP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                conn, err := mt.connectUDPTester.Connect(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Failed to connect", zap.String("target", target), zap.Error(err))
                        mt.metrics.ConnectUDPFailures++
                        continue</span>
                }

                <span class="cov0" title="0">mt.metrics.ConnectUDPSuccesses++

                // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–µ—Ä–µ–¥–∞—á—É –¥–∞–Ω–Ω—ã—Ö
                if err := mt.testDataTransfer(conn, "CONNECT-UDP", target); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Data transfer test failed", zap.String("target", target), zap.Error(err))
                }</span>

                // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                <span class="cov0" title="0">conn.Close()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testConnectIP —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç CONNECT-IP —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
func (mt *MASQUETester) testConnectIP(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting CONNECT-IP tests")

        for _, target := range mt.config.IPTargets </span><span class="cov0" title="0">{
                mt.logger.Info("Testing CONNECT-IP to target", zap.String("target", target))
                
                // –°–æ–∑–¥–∞–µ–º CONNECT-IP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                conn, err := mt.connectIPTester.Connect(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Failed to connect", zap.String("target", target), zap.Error(err))
                        mt.metrics.ConnectIPFailures++
                        continue</span>
                }

                <span class="cov0" title="0">mt.metrics.ConnectIPSuccesses++

                // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–µ—Ä–µ–¥–∞—á—É –¥–∞–Ω–Ω—ã—Ö
                if err := mt.testDataTransfer(conn, "CONNECT-IP", target); err != nil </span><span class="cov0" title="0">{
                        mt.logger.Error("Data transfer test failed", zap.String("target", target), zap.Error(err))
                }</span>

                // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                <span class="cov0" title="0">conn.Close()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// testHTTPDatagrams —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç HTTP Datagrams
func (mt *MASQUETester) testHTTPDatagrams(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting HTTP Datagrams tests")

        // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        testData := []byte("Hello, MASQUE HTTP Datagrams!")
        
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ datagrams
        sent, received, err := mt.capsuleTester.TestDatagrams(ctx, testData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP Datagrams test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.DatagramsSent += sent
        mt.metrics.DatagramsReceived += received

        // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ—Ç–µ—Ä–∏
        if sent &gt; 0 </span><span class="cov0" title="0">{
                mt.metrics.DatagramLossRate = float64(sent-received) / float64(sent) * 100
        }</span>

        <span class="cov0" title="0">mt.logger.Info("HTTP Datagrams test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received),
                zap.Float64("loss_rate", mt.metrics.DatagramLossRate))

        return nil</span>
}

// testCapsuleFallback —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç Capsule fallback –º–µ—Ö–∞–Ω–∏–∑–º
func (mt *MASQUETester) testCapsuleFallback(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting Capsule fallback tests")

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —á–µ—Ä–µ–∑ Capsules
        sent, received, err := mt.capsuleTester.TestCapsules(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Capsule fallback test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.CapsulesSent += sent
        mt.metrics.CapsulesReceived += received

        if sent &gt; received </span><span class="cov0" title="0">{
                mt.metrics.CapsuleFallbackCount++
        }</span>

        <span class="cov0" title="0">mt.logger.Info("Capsule fallback test completed",
                zap.Int64("sent", sent),
                zap.Int64("received", received))

        return nil</span>
}

// testPerformance —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å MASQUE
func (mt *MASQUETester) testPerformance(ctx context.Context) error <span class="cov0" title="0">{
        mt.logger.Info("Starting performance tests")

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–æ–ø—É—Å–∫–Ω—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å
        throughput, err := mt.capsuleTester.TestThroughput(ctx, mt.config.TestDuration)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Performance test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.Throughput = throughput

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É
        latency, err := mt.capsuleTester.TestLatency(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Latency test failed: %v", err)
        }</span>

        <span class="cov0" title="0">mt.metrics.AverageLatency = latency

        mt.logger.Info("Performance tests completed",
                zap.Float64("throughput_mbps", throughput),
                zap.Duration("average_latency", latency))

        return nil</span>
}

// testDataTransfer —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –ø–µ—Ä–µ–¥–∞—á—É –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (mt *MASQUETester) testDataTransfer(conn net.Conn, protocol, target string) error <span class="cov0" title="0">{
        mt.logger.Info("Testing data transfer",
                zap.String("protocol", protocol),
                zap.String("target", target))

        // –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        testData := []byte("Hello, MASQUE!")
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
        start := time.Now()
        _, err := conn.Write(testData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write data: %v", err)
        }</span>

        // –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
        <span class="cov0" title="0">buffer := make([]byte, len(testData))
        _, err = conn.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read data: %v", err)
        }</span>

        <span class="cov0" title="0">latency := time.Since(start)
        mt.metrics.AverageLatency = latency

        mt.logger.Info("Data transfer completed",
                zap.String("protocol", protocol),
                zap.String("target", target),
                zap.Duration("latency", latency))

        return nil</span>
}

// GetMetrics –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
func (mt *MASQUETester) GetMetrics() *MASQUEMetrics <span class="cov0" title="0">{
        mt.mu.RLock()
        defer mt.mu.RUnlock()
        return mt.metrics
}</span>

// GetStats –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
func (mt *MASQUETester) GetStats() *MASQUEStats <span class="cov0" title="0">{
        mt.mu.RLock()
        defer mt.mu.RUnlock()
        return mt.stats
}</span>

// IsActive –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–µ—Å—Ç–µ—Ä–∞
func (mt *MASQUETester) IsActive() bool <span class="cov0" title="0">{
        mt.mu.RLock()
        defer mt.mu.RUnlock()
        return mt.isActive
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package quic

import (
        "context"
        "crypto/tls"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/quic-go/quic-go"
        "go.uber.org/zap"
)

// QUICClient –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç QUIC –∫–ª–∏–µ–Ω—Ç
type QUICClient struct {
        logger      *zap.Logger
        serverAddr  string
        conn        *quic.Connection
        ctx         context.Context
        cancel      context.CancelFunc
        mu          sync.RWMutex
        isConnected bool
        streams     map[quic.StreamID]quic.Stream
}

// QUICClientConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è QUIC –∫–ª–∏–µ–Ω—Ç–∞
type QUICClientConfig struct {
        ServerAddr     string        `json:"server_addr"`
        MaxStreams     int           `json:"max_streams"`
        ConnectTimeout time.Duration `json:"connect_timeout"`
        IdleTimeout    time.Duration `json:"idle_timeout"`
}

// NewQUICClient —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π QUIC –∫–ª–∏–µ–Ω—Ç
func NewQUICClient(logger *zap.Logger, config *QUICClientConfig) *QUICClient <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;QUICClient{
                logger:     logger,
                serverAddr: config.ServerAddr,
                ctx:        ctx,
                cancel:     cancel,
                streams:    make(map[quic.StreamID]quic.Stream),
        }
}</span>

// Connect –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ QUIC —Å–µ—Ä–≤–µ—Ä—É
func (qc *QUICClient) Connect() error <span class="cov0" title="0">{
        qc.mu.Lock()
        defer qc.mu.Unlock()

        if qc.isConnected </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is already connected")
        }</span>

        // –°–æ–∑–¥–∞–µ–º QUIC –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        <span class="cov0" title="0">quicConfig := &amp;quic.Config{
                MaxIdleTimeout:  30 * time.Second,
                KeepAlivePeriod: 10 * time.Second,
        }

        // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É
        conn, err := quic.DialAddr(qc.ctx, qc.serverAddr, &amp;tls.Config{
                InsecureSkipVerify: true,
                NextProtos:         []string{"quic-test"},
        }, quicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to %s: %v", qc.serverAddr, err)
        }</span>

        <span class="cov0" title="0">qc.conn = &amp;conn
        qc.isConnected = true

        qc.logger.Info("QUIC client connected", zap.String("server", qc.serverAddr))

        // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –ø–æ—Ç–æ–∫–æ–≤
        go qc.handleStreams()

        return nil</span>
}

// Disconnect –æ—Ç–∫–ª—é—á–∞–µ—Ç—Å—è –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
func (qc *QUICClient) Disconnect() error <span class="cov0" title="0">{
        qc.mu.Lock()
        defer qc.mu.Unlock()

        if !qc.isConnected </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">qc.cancel()

        if qc.conn != nil </span><span class="cov0" title="0">{
                (*qc.conn).CloseWithError(0, "client disconnect")
        }</span>

        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ø–æ—Ç–æ–∫–∏
        <span class="cov0" title="0">for _, stream := range qc.streams </span><span class="cov0" title="0">{
                stream.Close()
        }</span>

        <span class="cov0" title="0">qc.isConnected = false
        qc.logger.Info("QUIC client disconnected")

        return nil</span>
}

// IsConnected –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
func (qc *QUICClient) IsConnected() bool <span class="cov0" title="0">{
        qc.mu.RLock()
        defer qc.mu.RUnlock()
        return qc.isConnected
}</span>

// GetStreams –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤
func (qc *QUICClient) GetStreams() int <span class="cov0" title="0">{
        qc.mu.RLock()
        defer qc.mu.RUnlock()
        return len(qc.streams)
}</span>

// SendData –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
func (qc *QUICClient) SendData(data []byte) error <span class="cov0" title="0">{
        qc.mu.RLock()
        defer qc.mu.RUnlock()

        if !qc.isConnected || qc.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client is not connected")
        }</span>

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫
        <span class="cov0" title="0">stream, err := (*qc.conn).OpenStreamSync(qc.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open stream: %v", err)
        }</span>

        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Ç–æ–∫ –≤ —Å–ø–∏—Å–æ–∫
        <span class="cov0" title="0">qc.mu.Lock()
        qc.streams[stream.StreamID()] = stream
        qc.mu.Unlock()

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
        _, err = stream.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                qc.mu.Lock()
                delete(qc.streams, stream.StreamID())
                qc.mu.Unlock()
                stream.Close()
                return fmt.Errorf("failed to send data: %v", err)
        }</span>

        <span class="cov0" title="0">qc.logger.Debug("Data sent to server",
                zap.Int("bytes", len(data)),
                zap.Uint64("stream_id", uint64(stream.StreamID())))

        return nil</span>
}

// SendTestData –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
func (qc *QUICClient) SendTestData(packetSize int, count int) error <span class="cov0" title="0">{
        if !qc.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("client is not connected")
        }</span>

        <span class="cov0" title="0">qc.logger.Info("Sending test data",
                zap.Int("packet_size", packetSize),
                zap.Int("count", count))

        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
                data := make([]byte, packetSize)
                for j := range data </span><span class="cov0" title="0">{
                        data[j] = byte(i + j)
                }</span>

                <span class="cov0" title="0">if err := qc.SendData(data); err != nil </span><span class="cov0" title="0">{
                        qc.logger.Error("Failed to send test data",
                                zap.Int("packet", i),
                                zap.Error(err))
                        return err
                }</span>

                // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–∞–∫–µ—Ç–∞–º–∏
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">qc.logger.Info("Test data sent successfully", zap.Int("packets", count))
        return nil</span>
}

// handleStreams –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ –ø–æ—Ç–æ–∫–∏
func (qc *QUICClient) handleStreams() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        if qc.conn == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">stream, err := (*qc.conn).AcceptStream(qc.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if qc.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">qc.logger.Debug("Failed to accept stream", zap.Error(err))
                                continue</span>
                        }

                        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Ç–æ–∫ –≤ —Å–ø–∏—Å–æ–∫
                        <span class="cov0" title="0">qc.mu.Lock()
                        qc.streams[stream.StreamID()] = stream
                        qc.mu.Unlock()

                        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ—Ç–æ–∫
                        go qc.handleStream(stream)</span>
                }
        }
}

// handleStream –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
func (qc *QUICClient) handleStream(stream quic.Stream) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // –£–¥–∞–ª—è–µ–º –ø–æ—Ç–æ–∫ –∏–∑ —Å–ø–∏—Å–∫–∞
                qc.mu.Lock()
                delete(qc.streams, stream.StreamID())
                qc.mu.Unlock()

                stream.Close()
                qc.logger.Debug("Stream closed", zap.Uint64("stream_id", uint64(stream.StreamID())))
        }</span>()

        <span class="cov0" title="0">buffer := make([]byte, 4096)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        n, err := stream.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        qc.logger.Debug("Stream EOF", zap.Uint64("stream_id", uint64(stream.StreamID())))
                                        return
                                }</span>
                                <span class="cov0" title="0">qc.logger.Debug("Stream read error", zap.Error(err))
                                return</span>
                        }

                        <span class="cov0" title="0">qc.logger.Debug("Received data from server",
                                zap.Uint64("stream_id", uint64(stream.StreamID())),
                                zap.Int("bytes", n))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package quic

import (
        "context"
        "fmt"
        "sync"
        "time"

        "go.uber.org/zap"
)

// QUICManager —É–ø—Ä–∞–≤–ª—è–µ—Ç QUIC —Å–µ—Ä–≤–µ—Ä–æ–º –∏ –∫–ª–∏–µ–Ω—Ç–æ–º
type QUICManager struct {
        logger *zap.Logger
        server *QUICServer
        client *QUICClient
        mu     sync.RWMutex
}

// QUICManagerConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
type QUICManagerConfig struct {
        ServerAddr     string        `json:"server_addr"`
        MaxConnections int           `json:"max_connections"`
        MaxStreams     int           `json:"max_streams"`
        ConnectTimeout time.Duration `json:"connect_timeout"`
        IdleTimeout    time.Duration `json:"idle_timeout"`
}

// NewQUICManager —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π QUIC –º–µ–Ω–µ–¥–∂–µ—Ä
func NewQUICManager(logger *zap.Logger, config *QUICManagerConfig) *QUICManager <span class="cov0" title="0">{
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–µ—Ä–∞
        serverConfig := &amp;QUICServerConfig{
                Addr:           config.ServerAddr,
                MaxConnections: config.MaxConnections,
                IdleTimeout:    config.IdleTimeout,
                KeepAlive:      10 * time.Second,
        }

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞
        clientConfig := &amp;QUICClientConfig{
                ServerAddr:     "localhost" + config.ServerAddr,
                MaxStreams:     config.MaxStreams,
                ConnectTimeout: config.ConnectTimeout,
                IdleTimeout:    config.IdleTimeout,
        }

        return &amp;QUICManager{
                logger: logger,
                server: NewQUICServer(logger, serverConfig),
                client: NewQUICClient(logger, clientConfig),
        }
}</span>

// StartServer –∑–∞–ø—É—Å–∫–∞–µ—Ç QUIC —Å–µ—Ä–≤–µ—Ä
func (qm *QUICManager) StartServer() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is already running")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Starting QUIC server")
        return qm.server.Start()</span>
}

// StopServer –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç QUIC —Å–µ—Ä–≤–µ—Ä
func (qm *QUICManager) StopServer() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if !qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is not running")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Stopping QUIC server")
        return qm.server.Stop()</span>
}

// StartClient –∑–∞–ø—É—Å–∫–∞–µ—Ç QUIC –∫–ª–∏–µ–Ω—Ç
func (qm *QUICManager) StartClient() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is already connected")
        }</span>

        <span class="cov0" title="0">if !qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is not running")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Starting QUIC client")
        return qm.client.Connect()</span>
}

// StopClient –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç QUIC –∫–ª–∏–µ–Ω—Ç
func (qm *QUICManager) StopClient() error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if !qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is not connected")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Stopping QUIC client")
        return qm.client.Disconnect()</span>
}

// SendTestData –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
func (qm *QUICManager) SendTestData(packetSize int, count int) error <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()

        if !qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is not connected")
        }</span>

        <span class="cov0" title="0">return qm.client.SendTestData(packetSize, count)</span>
}

// GetStatus –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞ –∏ –∫–ª–∏–µ–Ω—Ç–∞
func (qm *QUICManager) GetStatus() map[string]interface{} <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()

        return map[string]interface{}{
                "server": map[string]interface{}{
                        "running":     qm.server.IsRunning(),
                        "connections": qm.server.GetConnections(),
                },
                "client": map[string]interface{}{
                        "connected": qm.client.IsConnected(),
                        "streams":   qm.client.GetStreams(),
                },
        }
}</span>

// RunTest –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Ç–µ—Å—Ç QUIC —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (qm *QUICManager) RunTest(ctx context.Context, testConfig *TestConfig) error <span class="cov0" title="0">{
        qm.mu.Lock()
        defer qm.mu.Unlock()

        if !qm.server.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is not running")
        }</span>

        <span class="cov0" title="0">if !qm.client.IsConnected() </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC client is not connected")
        }</span>

        <span class="cov0" title="0">qm.logger.Info("Running QUIC test",
                zap.Int("packet_size", testConfig.PacketSize),
                zap.Int("packet_count", testConfig.PacketCount),
                zap.Duration("duration", testConfig.Duration))

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –≥–æ—Ä—É—Ç–∏–Ω–µ
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(time.Second)
                defer ticker.Stop()

                startTime := time.Now()
                packetsSent := 0

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if time.Since(startTime) &gt;= testConfig.Duration </span><span class="cov0" title="0">{
                                        qm.logger.Info("QUIC test completed",
                                                zap.Int("packets_sent", packetsSent),
                                                zap.Duration("duration", time.Since(startTime)))
                                        return
                                }</span>

                                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–∞–∫–µ—Ç—ã
                                <span class="cov0" title="0">if err := qm.client.SendTestData(testConfig.PacketSize, testConfig.PacketCount); err != nil </span><span class="cov0" title="0">{
                                        qm.logger.Error("Failed to send test data", zap.Error(err))
                                        return
                                }</span>

                                <span class="cov0" title="0">packetsSent += testConfig.PacketCount</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

// TestConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–∞
type TestConfig struct {
        PacketSize  int           `json:"packet_size"`
        PacketCount int           `json:"packet_count"`
        Duration    time.Duration `json:"duration"`
}

// GetServer –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä
func (qm *QUICManager) GetServer() *QUICServer <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()
        return qm.server
}</span>

// GetClient –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç
func (qm *QUICManager) GetClient() *QUICClient <span class="cov0" title="0">{
        qm.mu.RLock()
        defer qm.mu.RUnlock()
        return qm.client
}</span>

</pre>
		
		<pre class="file" id="file17" style="display: none">package quic

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "sync"
        "time"

        "github.com/quic-go/quic-go"
        "go.uber.org/zap"
)

// QUICServer –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç QUIC —Å–µ—Ä–≤–µ—Ä
type QUICServer struct {
        logger      *zap.Logger
        addr        string
        listener    *quic.Listener
        ctx         context.Context
        cancel      context.CancelFunc
        mu          sync.RWMutex
        isRunning   bool
        connections map[string]*quic.Connection
}

// QUICServerConfig –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è QUIC —Å–µ—Ä–≤–µ—Ä–∞
type QUICServerConfig struct {
        Addr           string        `json:"addr"`
        MaxConnections int           `json:"max_connections"`
        IdleTimeout    time.Duration `json:"idle_timeout"`
        KeepAlive      time.Duration `json:"keep_alive"`
}

// NewQUICServer —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π QUIC —Å–µ—Ä–≤–µ—Ä
func NewQUICServer(logger *zap.Logger, config *QUICServerConfig) *QUICServer <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;QUICServer{
                logger:      logger,
                addr:        config.Addr,
                ctx:         ctx,
                cancel:      cancel,
                connections: make(map[string]*quic.Connection),
        }
}</span>

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç QUIC —Å–µ—Ä–≤–µ—Ä
func (qs *QUICServer) Start() error <span class="cov0" title="0">{
        qs.mu.Lock()
        defer qs.mu.Unlock()

        if qs.isRunning </span><span class="cov0" title="0">{
                return fmt.Errorf("QUIC server is already running")
        }</span>

        // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é TLS –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
        <span class="cov0" title="0">cert, err := qs.generateSelfSignedCert()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate certificate: %v", err)
        }</span>

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                Certificates:       []tls.Certificate{cert},
                NextProtos:         []string{"quic-test"},
                InsecureSkipVerify: true,
        }

        // –°–æ–∑–¥–∞–µ–º QUIC –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        quicConfig := &amp;quic.Config{
                MaxIdleTimeout:  30 * time.Second,
                KeepAlivePeriod: 10 * time.Second,
        }

        // –°–æ–∑–¥–∞–µ–º listener
        listener, err := quic.ListenAddr(qs.addr, tlsConfig, quicConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %v", qs.addr, err)
        }</span>

        <span class="cov0" title="0">qs.listener = listener
        qs.isRunning = true

        qs.logger.Info("QUIC server started", zap.String("addr", qs.addr))

        // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
        go qs.handleConnections()

        return nil</span>
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç QUIC —Å–µ—Ä–≤–µ—Ä
func (qs *QUICServer) Stop() error <span class="cov0" title="0">{
        qs.mu.Lock()
        defer qs.mu.Unlock()

        if !qs.isRunning </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">qs.cancel()

        if qs.listener != nil </span><span class="cov0" title="0">{
                qs.listener.Close()
        }</span>

        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        <span class="cov0" title="0">for _, conn := range qs.connections </span><span class="cov0" title="0">{
                (*conn).CloseWithError(0, "server shutdown")
        }</span>

        <span class="cov0" title="0">qs.isRunning = false
        qs.logger.Info("QUIC server stopped")

        return nil</span>
}

// IsRunning –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞
func (qs *QUICServer) IsRunning() bool <span class="cov0" title="0">{
        qs.mu.RLock()
        defer qs.mu.RUnlock()
        return qs.isRunning
}</span>

// GetConnections –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
func (qs *QUICServer) GetConnections() int <span class="cov0" title="0">{
        qs.mu.RLock()
        defer qs.mu.RUnlock()
        return len(qs.connections)
}</span>

// handleConnections –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (qs *QUICServer) handleConnections() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qs.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        conn, err := qs.listener.Accept(qs.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if qs.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">qs.logger.Error("Failed to accept connection", zap.Error(err))
                                continue</span>
                        }

                        // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤ —Å–ø–∏—Å–æ–∫
                        <span class="cov0" title="0">qs.mu.Lock()
                        connID := fmt.Sprintf("%p", conn)
                        qs.connections[connID] = &amp;conn
                        qs.mu.Unlock()

                        qs.logger.Info("New QUIC connection accepted",
                                zap.String("conn_id", connID),
                                zap.String("remote_addr", conn.RemoteAddr().String()))

                        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                        go qs.handleConnection(&amp;conn, connID)</span>
                }
        }
}

// handleConnection –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
func (qs *QUICServer) handleConnection(conn *quic.Connection, connID string) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // –£–¥–∞–ª—è–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞
                qs.mu.Lock()
                delete(qs.connections, connID)
                qs.mu.Unlock()

                (*conn).CloseWithError(0, "connection closed")
                qs.logger.Info("QUIC connection closed", zap.String("conn_id", connID))
        }</span>()

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ—Ç–æ–∫–∏
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qs.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        stream, err := (*conn).AcceptStream(qs.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if qs.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">qs.logger.Debug("Failed to accept stream", zap.Error(err))
                                continue</span>
                        }

                        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ—Ç–æ–∫
                        <span class="cov0" title="0">go qs.handleStream(stream, connID)</span>
                }
        }
}

// handleStream –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö
func (qs *QUICServer) handleStream(stream quic.Stream, connID string) <span class="cov0" title="0">{
        defer stream.Close()

        buffer := make([]byte, 4096)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-qs.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        n, err := stream.Read(buffer)
                        if err != nil </span><span class="cov0" title="0">{
                                qs.logger.Debug("Stream read error", zap.Error(err))
                                return
                        }</span>

                        <span class="cov0" title="0">qs.logger.Debug("Received data",
                                zap.String("conn_id", connID),
                                zap.Int("bytes", n))

                        // –≠—Ö–æ-–æ—Ç–≤–µ—Ç
                        _, err = stream.Write(buffer[:n])
                        if err != nil </span><span class="cov0" title="0">{
                                qs.logger.Debug("Stream write error", zap.Error(err))
                                return
                        }</span>
                }
        }
}

// generateTLSConfig —Å–æ–∑–¥–∞–µ—Ç TLS –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
func (qs *QUICServer) generateTLSConfig() (*tls.Config, error) <span class="cov0" title="0">{
        // –°–æ–∑–¥–∞–µ–º —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç
        cert, err := qs.generateSelfSignedCert()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;tls.Config{
                Certificates:       []tls.Certificate{cert},
                NextProtos:         []string{"quic-test"},
                InsecureSkipVerify: true,
        }, nil</span>
}

// generateSelfSignedCert —Å–æ–∑–¥–∞–µ—Ç —Å–∞–º–æ–ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç
func (qs *QUICServer) generateSelfSignedCert() (tls.Certificate, error) <span class="cov0" title="0">{
        // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á
        priv, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        // –°–æ–∑–¥–∞–µ–º —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç
        <span class="cov0" title="0">template := x509.Certificate{
                SerialNumber: big.NewInt(1),
                Subject: pkix.Name{
                        Organization:  []string{"QUCK Test"},
                        Country:       []string{"US"},
                        Province:      []string{""},
                        Locality:      []string{"San Francisco"},
                        StreetAddress: []string{""},
                        PostalCode:    []string{""},
                },
                NotBefore:   time.Now(),
                NotAfter:    time.Now().Add(365 * 24 * time.Hour),
                KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                IPAddresses: []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},
        }

        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;priv.PublicKey, priv)
        if err != nil </span><span class="cov0" title="0">{
                return tls.Certificate{}, err
        }</span>

        // –ö–æ–¥–∏—Ä—É–µ–º –≤ PEM
        <span class="cov0" title="0">certPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})
        keyPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)})

        // –°–æ–∑–¥–∞–µ–º TLS —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç
        return tls.X509KeyPair(certPEM, keyPEM)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package internal

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strings"
)

// SaveReport —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ—Ç—á—ë—Ç –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ç–µ—Å—Ç–∞ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
func SaveReport(cfg TestConfig, metrics any) error <span class="cov0" title="0">{
        format := strings.ToLower(cfg.ReportFormat)
        if format == "" </span><span class="cov0" title="0">{
                format = "md"
        }</span>
        <span class="cov0" title="0">filename := cfg.ReportPath
        if filename == "" </span><span class="cov0" title="0">{
                filename = fmt.Sprintf("report.%s", format)
        }</span>

        <span class="cov0" title="0">var data []byte
        var err error

        switch format </span>{
        case "json":<span class="cov0" title="0">
                data, err = json.MarshalIndent(makeReportJSON(cfg, metrics), "", "  ")</span>
        case "csv":<span class="cov0" title="0">
                return saveCSV(filename, makeReportCSV(cfg, metrics))</span>
        case "md":<span class="cov0" title="0">
                data = []byte(makeReportMarkdown(cfg, metrics))</span>
        default:<span class="cov0" title="0">
                data = []byte(makeReportMarkdown(cfg, metrics))</span>
        }

        <span class="cov0" title="0">if format != "csv" </span><span class="cov0" title="0">{
                err = os.WriteFile(filename, data, 0644)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—Ç—á—ë—Ç–∞: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("\n–û—Ç—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω:", filename)
        return nil</span>
}

// --- –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ---

func makeReportJSON(cfg TestConfig, metrics any) any <span class="cov0" title="0">{
        return map[string]any{
                "params": cfg,
                "metrics": metrics,
        }
}</span>

func makeReportCSV(cfg TestConfig, metrics any) [][]string <span class="cov0" title="0">{
        // TODO: —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—é –≤ CSV
        return [][]string{{"param", "value"}, {"mode", cfg.Mode}}
}</span>

func saveCSV(filename string, rows [][]string) error <span class="cov0" title="0">{
        f, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        w := csv.NewWriter(f)
        defer w.Flush()
        return w.WriteAll(rows)</span>
}

func makeReportMarkdown(cfg TestConfig, metrics any) string <span class="cov0" title="0">{
        m, ok := metrics.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("# 2GC CloudBridge QUICK testing\n\n**–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:** \"%+v\"\n\n**–ú–µ—Ç—Ä–∏–∫–∏:** \"%+v\"\n", cfg, metrics)
        }</span>
        <span class="cov0" title="0">latencies, _ := m["Latencies"].([]float64)
        p50, p95, p99 := calcPercentiles(latencies)
        jitter := calcJitter(latencies)
        avg := avgLatency(latencies)

        tsLatency, _ := m["TimeSeriesLatency"].([]interface{})
        tsThroughput, _ := m["TimeSeriesThroughput"].([]interface{})
        tsPacketLoss, _ := m["TimeSeriesPacketLoss"].([]interface{})
        tsRetransmits, _ := m["TimeSeriesRetransmits"].([]interface{})
        tsHandshakeTime, _ := m["TimeSeriesHandshakeTime"].([]interface{})

        var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf(`# 2GC CloudBridge QUICK testing\n\n**–ü–∞—Ä–∞–º–µ—Ç—Ä—ã:** "%+v"\n\n**–ú–µ—Ç—Ä–∏–∫–∏:**\n\n- Success: %v\n- Errors: %v\n- BytesSent: %v\n- Avg Latency: %.2f ms\n- p50: %.2f ms\n- p95: %.2f ms\n- p99: %.2f ms\n- Jitter: %.2f ms\n- PacketLoss: %v %%\n- Retransmits: %v\n- TLSVersion: %v\n- CipherSuite: %v\n- SessionResumptionCount: %v\n- 0-RTT: %v\n- 1-RTT: %v\n- OutOfOrder: %v\n- FlowControlEvents: %v\n- KeyUpdateEvents: %v\n- ErrorTypeCounts: %v\n`, cfg, m["Success"], m["Errors"], m["BytesSent"], avg, p50, p95, p99, jitter, m["PacketLoss"], m["Retransmits"], m["TLSVersion"], m["CipherSuite"], m["SessionResumptionCount"], m["ZeroRTTCount"], m["OneRTTCount"], m["OutOfOrderCount"], m["FlowControlEvents"], m["KeyUpdateEvents"], m["ErrorTypeCounts"]))

        buf.WriteString("\n## –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä—è–¥—ã (Time Series)\n")
        buf.WriteString("\n### Latency (ms)\n")
        buf.WriteString("| Time (s) | Latency (ms) |\n|---|---|\n")
        for _, v := range tsLatency </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Throughput (KB/s)\n| Time (s) | Throughput (KB/s) |\n|---|---|\n")
        for _, v := range tsThroughput </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Packet Loss (%)\n| Time (s) | Packet Loss (%) |\n|---|---|\n")
        for _, v := range tsPacketLoss </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Retransmits\n| Time (s) | Retransmits |\n|---|---|\n")
        for _, v := range tsRetransmits </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.0f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n### Handshake Time (ms)\n| Time (s) | Handshake Time (ms) |\n|---|---|\n")
        for _, v := range tsHandshakeTime </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("| %.0f | %.2f |\n", point["Time"].(float64), point["Value"].(float64)))
                }</span>
        }
        // ASCII-–≥—Ä–∞—Ñ–∏–∫–∏
        <span class="cov0" title="0">buf.WriteString("\n#### Latency Graph (ASCII)\n\n```")
        var latencyVals []float64
        for _, v := range tsLatency </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        latencyVals = append(latencyVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(latencyVals, "Latency ms") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Throughput Graph (ASCII)\n\n```")
        var throughputVals []float64
        for _, v := range tsThroughput </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        throughputVals = append(throughputVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(throughputVals, "Throughput KB/s") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Packet Loss Graph (ASCII)\n\n```")
        var lossVals []float64
        for _, v := range tsPacketLoss </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        lossVals = append(lossVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(lossVals, "Packet Loss %") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Retransmits Graph (ASCII)\n\n```")
        var retransVals []float64
        for _, v := range tsRetransmits </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        retransVals = append(retransVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(retransVals, "Retransmits") + "\n")
        buf.WriteString("```")
        buf.WriteString("\n#### Handshake Time Graph (ASCII)\n\n```")
        var hsVals []float64
        for _, v := range tsHandshakeTime </span><span class="cov0" title="0">{
                point, ok := v.(map[string]interface{})
                if ok </span><span class="cov0" title="0">{
                        hsVals = append(hsVals, point["Value"].(float64))
                }</span>
        }
        <span class="cov0" title="0">buf.WriteString("\n" + asciigraphPlot(hsVals, "Handshake Time ms") + "\n")
        buf.WriteString("```")
        return buf.String()</span>
}

// ascii-–≥—Ä–∞—Ñ–∏–∫ (–∑–∞–≥–ª—É—à–∫–∞, –µ—Å–ª–∏ –Ω–µ—Ç asciigraph)
func asciigraphPlot(data []float64, caption string) string <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        // –ú–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å asciigraph, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω, –∏–Ω–∞—á–µ –ø—Ä–æ—Å—Ç–∞—è –∑–∞–≥–ª—É—à–∫–∞
        <span class="cov0" title="0">max := data[0]
        min := data[0]
        for _, v := range data </span><span class="cov0" title="0">{
                if v &gt; max </span><span class="cov0" title="0">{
                        max = v
                }</span>
                <span class="cov0" title="0">if v &lt; min </span><span class="cov0" title="0">{
                        min = v
                }</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s: min=%.2f max=%.2f (graph suppressed)\n", caption, min, max)</span>
}

// calcPercentiles –∏ calcJitter (–¥—É–±–ª–∏—Ä—É–µ–º –¥–ª—è –æ—Ç—á—ë—Ç–∞)
func calcPercentiles(latencies []float64) (p50, p95, p99 float64) <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0, 0, 0
        }</span>
        <span class="cov0" title="0">copyLat := make([]float64, len(latencies))
        copy(copyLat, latencies)
        sort.Float64s(copyLat)
        idx := func(p float64) int </span><span class="cov0" title="0">{
                return int(p*float64(len(copyLat)-1) + 0.5)
        }</span>
        <span class="cov0" title="0">p50 = copyLat[idx(0.50)]
        p95 = copyLat[idx(0.95)]
        p99 = copyLat[idx(0.99)]
        return</span>
}
func calcJitter(latencies []float64) float64 <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">mean := 0.0
        for _, l := range latencies </span><span class="cov0" title="0">{
                mean += l
        }</span>
        <span class="cov0" title="0">mean /= float64(len(latencies))
        var sum float64
        for _, l := range latencies </span><span class="cov0" title="0">{
                d := l - mean
                sum += d * d
        }</span>
        <span class="cov0" title="0">return (sum / float64(len(latencies)))</span>
}
func avgLatency(latencies []float64) float64 <span class="cov0" title="0">{
        if len(latencies) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">sum := 0.0
        for _, l := range latencies </span><span class="cov0" title="0">{
                sum += l
        }</span>
        <span class="cov0" title="0">return sum / float64(len(latencies))</span>
} </pre>
		
		<pre class="file" id="file19" style="display: none">package internal

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "math/big"
        "time"
)

// GenerateSelfSignedTLS –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç self-signed —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –∏ –∫–ª—é—á –¥–ª—è TLS
func GenerateSelfSignedTLS() (certPEM, keyPEM []byte) <span class="cov0" title="0">{
        priv, _ := rsa.GenerateKey(rand.Reader, 2048)
        serial := big.NewInt(time.Now().UnixNano())
        certTmpl := x509.Certificate{
                SerialNumber: serial,
                Subject: pkix.Name{Organization: []string{"quck-test"}},
                NotBefore: time.Now(),
                NotAfter:  time.Now().Add(24 * time.Hour),
                KeyUsage:  x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
                BasicConstraintsValid: true,
        }
        certDER, _ := x509.CreateCertificate(rand.Reader, &amp;certTmpl, &amp;certTmpl, &amp;priv.PublicKey, priv)
        certPEM = pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER})
        keyPEM = pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)})
        return certPEM, keyPEM
}</span> </pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "quic-test/client"
        "quic-test/internal"
        "quic-test/server"
)

func main() <span class="cov0" title="0">{
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("\033[1;36m  2GC CloudBridge QUICK testing\033[0m")
        fmt.Println("\033[1;36m==============================\033[0m")
        fmt.Println("–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ QUIC-–ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –¥–ª—è CloudBridge 2GC")
        mode := flag.String("mode", "test", "–†–µ–∂–∏–º: server | client | test")
        addr := flag.String("addr", ":9000", "–ê–¥—Ä–µ—Å –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏–ª–∏ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è")
        streams := flag.Int("streams", 1, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ –Ω–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ")
        connections := flag.Int("connections", 1, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ QUIC-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π")
        duration := flag.Duration("duration", 0, "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∞ (0 ‚Äî –¥–æ —Ä—É—á–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è)")
        packetSize := flag.Int("packet-size", 1200, "–†–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞ (–±–∞–π—Ç)")
        rate := flag.Int("rate", 100, "–ß–∞—Å—Ç–æ—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∞–∫–µ—Ç–æ–≤ (–≤ —Å–µ–∫—É–Ω–¥—É)")
        reportPath := flag.String("report", "", "–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –æ—Ç—á–µ—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        reportFormat := flag.String("report-format", "md", "–§–æ—Ä–º–∞—Ç –æ—Ç—á–µ—Ç–∞: csv | md | json")
        certPath := flag.String("cert", "", "–ü—É—Ç—å –∫ TLS-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        keyPath := flag.String("key", "", "–ü—É—Ç—å –∫ TLS-–∫–ª—é—á—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)")
        pattern := flag.String("pattern", "random", "–®–∞–±–ª–æ–Ω –¥–∞–Ω–Ω—ã—Ö: random | zeroes | increment")
        noTLS := flag.Bool("no-tls", false, "–û—Ç–∫–ª—é—á–∏—Ç—å TLS (–¥–ª—è —Ç–µ—Å—Ç–æ–≤)")
        prometheus := flag.Bool("prometheus", false, "–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ Prometheus –Ω–∞ /metrics")
        emulateLoss := flag.Float64("emulate-loss", 0, "–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ—Ç–µ—Ä–∏ –ø–∞–∫–µ—Ç–∞ (0..1)")
        emulateLatency := flag.Duration("emulate-latency", 0, "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –ø–∞–∫–µ—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 20ms)")
        emulateDup := flag.Float64("emulate-dup", 0, "–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞–∫–µ—Ç–∞ (0..1)")
        flag.Parse()

        cfg := internal.TestConfig{
                Mode:           *mode,
                Addr:           *addr,
                Streams:        *streams,
                Connections:    *connections,
                Duration:       *duration,
                PacketSize:     *packetSize,
                Rate:           *rate,
                ReportPath:     *reportPath,
                ReportFormat:   *reportFormat,
                CertPath:       *certPath,
                KeyPath:        *keyPath,
                Pattern:        *pattern,
                NoTLS:          *noTLS,
                Prometheus:     *prometheus,
                EmulateLoss:    *emulateLoss,
                EmulateLatency: *emulateLatency,
                EmulateDup:     *emulateDup,
        }

        fmt.Printf("mode=%s, addr=%s, connections=%d, streams=%d, duration=%s, packet-size=%d, rate=%d, report=%s, report-format=%s, cert=%s, key=%s, pattern=%s, no-tls=%v, prometheus=%v\n",
                cfg.Mode, cfg.Addr, cfg.Connections, cfg.Streams, cfg.Duration.String(), cfg.PacketSize, cfg.Rate, cfg.ReportPath, cfg.ReportFormat, cfg.CertPath, cfg.KeyPath, cfg.Pattern, cfg.NoTLS, cfg.Prometheus)

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è graceful shutdown
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        _, cancel := context.WithCancel(context.Background())
        defer cancel()

        go func(cancelFunc context.CancelFunc) </span><span class="cov0" title="0">{
                &lt;-sigs
                fmt.Println("\n–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è, –∑–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É...")
                cancelFunc() // –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        }</span>(cancel)

        <span class="cov0" title="0">switch cfg.Mode </span>{
        case "server":<span class="cov0" title="0">
                fmt.Println("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ —Å–µ—Ä–≤–µ—Ä–∞...")
                server.Run(cfg)</span>
        case "client":<span class="cov0" title="0">
                fmt.Println("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ –∫–ª–∏–µ–Ω—Ç–∞...")
                client.Run(cfg)</span>
        case "test":<span class="cov0" title="0">
                fmt.Println("–ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ —Ç–µ—Å—Ç–∞ (—Å–µ—Ä–≤–µ—Ä+–∫–ª–∏–µ–Ω—Ç)...")</span>
                // TODO: –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –∏ –∫–ª–∏–µ–Ω—Ç–∞ –≤ –æ–¥–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ
        default:<span class="cov0" title="0">
                fmt.Println("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º", cfg.Mode)
                os.Exit(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package server

import (
        "context"
        "crypto/tls"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "quic-test/internal"

        "github.com/fatih/color"
        "github.com/olekukonko/tablewriter"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        quic "github.com/quic-go/quic-go"
)

// serverMetrics —Ö—Ä–∞–Ω–∏—Ç –º–µ—Ç—Ä–∏–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞
type serverMetrics struct {
        mu          sync.Mutex
        Connections int
        Streams     int
        Bytes       int64
        Errors      int
        Start       time.Time
}

// Run –∑–∞–ø—É—Å–∫–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∏–∑ TestConfig
func Run(cfg internal.TestConfig) <span class="cov0" title="0">{
        metrics := &amp;serverMetrics{Start: time.Now()}

        if cfg.Prometheus </span><span class="cov0" title="0">{
                go startPrometheusExporter(metrics)
        }</span>

        <span class="cov0" title="0">tlsConf := makeTLSConfig(cfg)
        listener, err := quic.ListenAddr(cfg.Addr, tlsConf, &amp;quic.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ QUIC —Å–µ—Ä–≤–µ—Ä–∞: %v", err)
        }</span>
        <span class="cov0" title="0">log.Printf("QUIC —Å–µ—Ä–≤–µ—Ä —Å–ª—É—à–∞–µ—Ç %s", cfg.Addr)

        done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                c := make(chan os.Signal, 1)
                signal.Notify(c, os.Interrupt, syscall.SIGTERM)
                &lt;-c
                log.Println("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞...")
                listener.Close()
                close(done)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        conn, err := listener.Accept(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                metrics.mu.Lock()
                                metrics.Errors++
                                metrics.mu.Unlock()
                                break</span>
                        }
                        <span class="cov0" title="0">metrics.mu.Lock()
                        metrics.Connections++
                        metrics.mu.Unlock()
                        go handleConn(conn, metrics)</span>
                }
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                        printServerMetrics(metrics)</span>
                }
        }
}

func handleConn(conn quic.Connection, metrics *serverMetrics) <span class="cov0" title="0">{
        defer conn.CloseWithError(0, "bye")
        for </span><span class="cov0" title="0">{
                stream, err := conn.AcceptStream(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.Errors++
                        metrics.mu.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">metrics.mu.Lock()
                metrics.Streams++
                metrics.mu.Unlock()
                go handleStream(stream, metrics)</span>
        }
}

func handleStream(stream quic.Stream, metrics *serverMetrics) <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        for </span><span class="cov0" title="0">{
                n, err := stream.Read(buf)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        metrics.mu.Lock()
                        metrics.Bytes += int64(n)
                        metrics.mu.Unlock()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if err.Error() != "EOF" </span><span class="cov0" title="0">{
                                metrics.mu.Lock()
                                metrics.Errors++
                                metrics.mu.Unlock()
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
}

func makeTLSConfig(cfg internal.TestConfig) *tls.Config <span class="cov0" title="0">{
        if cfg.NoTLS </span><span class="cov0" title="0">{
                return &amp;tls.Config{InsecureSkipVerify: true, NextProtos: []string{"quic-test"}}
        }</span>
        <span class="cov0" title="0">if cfg.CertPath != "" &amp;&amp; cfg.KeyPath != "" </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(cfg.CertPath, cfg.KeyPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞: %v", err)
                }</span>
                <span class="cov0" title="0">return &amp;tls.Config{Certificates: []tls.Certificate{cert}, NextProtos: []string{"quic-test"}}</span>
        }
        <span class="cov0" title="0">certPEM, keyPEM := internal.GenerateSelfSignedTLS()
        cert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ self-signed —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;tls.Config{Certificates: []tls.Certificate{cert}, NextProtos: []string{"quic-test"}}</span>
}

func printServerMetrics(metrics *serverMetrics) <span class="cov0" title="0">{
        metrics.mu.Lock()
        defer metrics.mu.Unlock()

        fmt.Print("\033[H\033[2J")
        fmt.Println("\033[1;36m  2GC CloudBridge QUICK testing Server\033[0m")

        green := color.New(color.FgGreen).SprintFunc()
        red := color.New(color.FgRed).SprintFunc()
        blue := color.New(color.FgBlue).SprintFunc()
        yellow := color.New(color.FgYellow).SprintFunc()

        table := tablewriter.NewWriter(os.Stdout)
        headers := []string{"Connections", "Streams", "Bytes", "Errors", "Uptime (s)"}
        table.Append(headers)
        uptime := time.Since(metrics.Start).Seconds()
        row := []string{
                green(fmt.Sprintf("%d", metrics.Connections)),
                blue(fmt.Sprintf("%d", metrics.Streams)),
                blue(fmt.Sprintf("%.2f KB", float64(metrics.Bytes)/1024)),
                red(fmt.Sprintf("%d", metrics.Errors)),
                yellow(fmt.Sprintf("%.0f", uptime)),
        }
        table.Append(row)
        table.Render()
}</span>

func startPrometheusExporter(metrics *serverMetrics) <span class="cov0" title="0">{
        connections := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_connections_total",
                Help: "Total connections",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Connections)
        }</span>)
        <span class="cov0" title="0">streams := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_streams_total",
                Help: "Total streams",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Streams)
        }</span>)
        <span class="cov0" title="0">bytes := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_bytes_total",
                Help: "Total bytes received",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Bytes)
        }</span>)
        <span class="cov0" title="0">errors := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_errors_total",
                Help: "Total errors",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return float64(metrics.Errors)
        }</span>)
        <span class="cov0" title="0">uptime := prometheus.NewGaugeFunc(prometheus.GaugeOpts{
                Name: "quic_server_uptime_seconds",
                Help: "Server uptime in seconds",
        }, func() float64 </span><span class="cov0" title="0">{
                metrics.mu.Lock()
                defer metrics.mu.Unlock()
                return time.Since(metrics.Start).Seconds()
        }</span>)

        <span class="cov0" title="0">prometheus.MustRegister(connections, streams, bytes, errors, uptime)
        http.Handle("/metrics", promhttp.Handler())
        fmt.Println("Prometheus endpoint —Å–µ—Ä–≤–µ—Ä–∞ –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ :2113/metrics")
        http.ListenAndServe(":2113", nil)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
